import { GameRenderer } from './engine/GameRenderer';
import { InputManager } from './engine/InputManager';
import { GameScene, EnvironmentType, GameMode } from './types/core';

/**
 * üéÆ AI Habitat: Harmony or Havoc? ‚Äî Detailed Design Implementation
 * 
 * A sandbox simulation where players invent LLM-powered smart devices for homes/hospitals/offices,
 * then watch them cooperate or collide. The game explains why conflicts happen and lets players
 * govern the world with rules to restore harmony.
 * 
 * Core Loop: Create devices ‚Üí Simulate a day ‚Üí Observe outcomes ‚Üí Explain causes ‚Üí Add governance rules ‚Üí Re-simulate
 */
class AIHabitatGame {
  private gameRenderer: GameRenderer;
  private inputManager: InputManager;
  private gameContainer: HTMLElement;
  private loadingScreen: HTMLElement;
  private deviceCount: number = 0;
  private interactionCount: number = 0;
  private currentEnvironment: 'home' | 'hospital' | 'office' = 'home';
  private systemHealth: number = 100; // 0-100, where 100 is perfect harmony
  // **DEVICE SPEC SYSTEM** - The crucial glue from your design
  private smartDevices: Array<DeviceSpec & {
    element: HTMLElement;
    x: number;
    y: number;
    status: 'idle' | 'thinking' | 'acting' | 'negotiating' | 'conflicting' | 'cooperating';
    currentAction: string;
    currentThought: string;
    memory: {
      short: string[]; // conversation history
      long: any[]; // preferences, incidents
    };
    lastStep: AgentStep | null;
    isActive: boolean;
  }> = [];

  // **TYPE DEFINITIONS** - From your design document
  interface Goal {
    name: string;
    weight: number;
  }

  interface Constraint {
    name: string;
  }

  interface DeviceSpec {
    id: string;
    name: string;
    room: string;
    goals: Goal[];
    constraints: Constraint[];
    sensors: string[];
    actuators: string[];
    personality: string;
    defaults: Record<string, any>;
    communication: {
      style: string;
      topics: string[];
    };
    learning: {
      type: 'bandit' | 'ema';
      memory_horizon_days: number;
    };
    risk_flags: string[];
    llm_prompt: string;
  }

  interface Action {
    name: string;
    args: Record<string, any>;
  }

  interface AgentStep {
    messages_to: { to: string; content: string }[];
    actions: Action[];
    explain: string;
  }
  
  // **WORLD MODEL** - Discrete time simulator (10s ticks)
  private worldState: {
    tick: number; // Current simulation tick
    timeOfDay: 'morning' | 'afternoon' | 'evening' | 'night';
    rooms: Map<string, RoomState>; // Room ambient variables
    resources: {
      energy: { current: number; max: number; cost: number };
      bandwidth: { current: number; max: number };
      attention: { current: number; max: number };
      privacy_budget: { current: number; max: number };
    };
    globalPriorities: string[]; // e.g., ['Safety', 'Comfort', 'Efficiency', 'Privacy']
    events: WorldEvent[];
    conflicts: ConflictEvent[];
    systemHealth: number; // 0-100, Harmony ‚Üí Crash
  } = {
    tick: 0,
    timeOfDay: 'morning',
    rooms: new Map([
      ['living_room', { temperature: 22, lumens: 300, noise: 30, occupancy: 1 }],
      ['bedroom', { temperature: 20, lumens: 100, noise: 20, occupancy: 0 }],
      ['kitchen', { temperature: 24, lumens: 400, noise: 40, occupancy: 0 }]
    ]),
    resources: {
      energy: { current: 80, max: 100, cost: 0 },
      bandwidth: { current: 90, max: 100 },
      attention: { current: 70, max: 100 },
      privacy_budget: { current: 60, max: 100 }
    },
    globalPriorities: ['Safety', 'Comfort', 'Efficiency', 'Privacy'],
    events: [],
    conflicts: [],
    systemHealth: 100
  };

  interface RoomState {
    temperature: number;
    lumens: number;
    noise: number;
    occupancy: number;
  }

  interface WorldEvent {
    tick: number;
    type: string;
    description: string;
    causedBy?: string;
  }

  interface ConflictEvent {
    tick: number;
    devices: string[];
    variable: string;
    description: string;
    resolution: string;
  }
  
  // **GOVERNANCE SYSTEM** - Player's main tool
  private governance: {
    constitution: string[]; // Immutable rules
    policies: {
      priorityOrder: string[];
      quietHours: { start: number; end: number };
      privacyCaps: Record<string, number>;
      energyLimits: { max: number; warning: number };
    };
    contextualRules: Array<{
      condition: string;
      rule: string;
      priority: number;
    }>;
    escalation: {
      conflictThreshold: number;
      timeWindow: number;
      action: string;
    };
  } = {
    constitution: [
      'Never harm humans',
      'Respect safety overrides',
      'Maintain system stability'
    ],
    policies: {
      priorityOrder: ['Safety', 'Comfort', 'Efficiency', 'Privacy'],
      quietHours: { start: 22, end: 6 },
      privacyCaps: { data_collection: 70, sharing: 30 },
      energyLimits: { max: 100, warning: 80 }
    },
    contextualRules: [],
    escalation: {
      conflictThreshold: 3,
      timeWindow: 120, // 2 minutes in ticks
      action: 'safe_mode'
    }
  };

  // **SIMULATION CONTROL**
  private simulationState: {
    isRunning: boolean;
    isPaused: boolean;
    speed: number; // 1x, 2x, 4x
    tickInterval: any;
  } = {
    isRunning: false,
    isPaused: false,
    speed: 1,
    tickInterval: null
  };

  private interactionDashboard: HTMLElement | null = null;
  private governancePanel: HTMLElement | null = null;
  private explainerPanel: HTMLElement | null = null;

  constructor() {
    console.log('üèóÔ∏è Constructing AIHabitatGame...');
    
    this.gameContainer = document.getElementById('game-container')!;
    this.loadingScreen = document.getElementById('loading-screen')!;
    
    if (!this.gameContainer) {
      console.error('‚ùå Game container not found!');
      this.showErrorScreen(new Error('Game container element not found. Please check the HTML.'));
      return;
    }
    
    if (!this.loadingScreen) {
      console.error('‚ùå Loading screen not found!');
      this.showErrorScreen(new Error('Loading screen element not found. Please check the HTML.'));
      return;
    }
    
    console.log('‚úÖ DOM elements found, starting initialization...');
    this.initializeGame();
  }

  private async initializeGame(): Promise<void> {
    try {
      console.log('üéÆ Starting AI Habitat initialization...');
      
      // Show loading messages with delays to make it visible
      this.showLoadingMessage('Initializing game engine...');
      this.updateLoadingProgress({ progress: 10, phase: 'initializing' });
      await this.delay(300);
      
      this.showLoadingMessage('Setting up renderer...');
      this.updateLoadingProgress({ progress: 30, phase: 'loading-core' });
      await this.delay(300);
      
      // Always use fallback for now to ensure it works
      console.log('üé® Using simplified renderer for demo...');
      this.createFallbackRenderer();
      
      this.showLoadingMessage('Setting up input system...');
      this.updateLoadingProgress({ progress: 50, phase: 'loading-core' });
      await this.delay(300);
      
      this.createFallbackInput();
      
      this.showLoadingMessage('Creating game world...');
      this.updateLoadingProgress({ progress: 70, phase: 'loading-assets' });
      await this.delay(300);
      
      this.createGameWorld();
      
      this.showLoadingMessage('Finalizing...');
      this.updateLoadingProgress({ progress: 90, phase: 'loading-assets' });
      await this.delay(300);
      
      // Set up event handlers
      this.setupEventHandlers();
      this.updateLoadingProgress({ progress: 100, phase: 'complete' });
      await this.delay(200);
      
      // Hide loading screen
      this.hideLoadingScreen();
      
      // Show welcome message immediately
      console.log('üéâ Showing welcome message...');
      this.showWelcomeMessage();
      
      console.log('‚úÖ AI Habitat initialized successfully!');
      
      // Add game interface immediately
      this.addGameInterface();
      
      // Add demo menu after welcome message
      setTimeout(() => {
        this.addDemoMenu();
      }, 2000);
      
    } catch (error) {
      console.error('‚ùå Failed to initialize game:', error);
      this.showErrorScreen(error as Error);
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  private showLoadingMessage(message: string): void {
    console.log(`üí¨ Loading: ${message}`);
    
    const loadingText = this.loadingScreen.querySelector('.loading-text');
    if (loadingText) {
      loadingText.textContent = message;
    } else {
      console.warn('‚ö†Ô∏è Loading text element not found');
    }
  }

  private updateLoadingProgress(progress: any): void {
    console.log(`üìä Loading progress: ${progress.progress}% - ${progress.phase}`);
    
    const progressBar = this.loadingScreen.querySelector('.progress-bar') as HTMLElement;
    const progressText = this.loadingScreen.querySelector('.progress-text') as HTMLElement;
    const phaseText = this.loadingScreen.querySelector('.phase-text') as HTMLElement;

    if (progressBar) {
      progressBar.style.width = `${progress.progress}%`;
    }

    if (progressText) {
      progressText.textContent = `${Math.round(progress.progress)}%`;
    }

    if (phaseText) {
      const phaseNames = {
        'initializing': 'Initializing...',
        'loading-critical': 'Loading core systems...',
        'loading-core': 'Loading game engine...',
        'loading-assets': 'Loading assets...',
        'complete': 'Ready to play!'
      };
      phaseText.textContent = phaseNames[progress.phase as keyof typeof phaseNames] || progress.phase;
    }

    if (progress.currentAsset) {
      const assetText = this.loadingScreen.querySelector('.asset-text') as HTMLElement;
      if (assetText) {
        assetText.textContent = `Loading: ${progress.currentAsset}`;
      }
    }
  }

  private createFallbackRenderer(): void {
    console.log('üé® Creating fallback 2D renderer...');
    
    // Create a simple canvas-based renderer
    const canvas = document.createElement('canvas');
    canvas.width = this.gameContainer.clientWidth;
    canvas.height = this.gameContainer.clientHeight;
    canvas.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
    `;
    
    this.gameContainer.appendChild(canvas);
    
    const ctx = canvas.getContext('2d');
    if (ctx) {
      // Draw a simple grid pattern
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.lineWidth = 1;
      
      const gridSize = 50;
      for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      
      for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
      
      // Draw welcome text
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('AI Habitat Demo Environment', canvas.width / 2, canvas.height / 2 - 20);
      
      ctx.font = '16px Arial';
      ctx.fillText('Click anywhere to interact', canvas.width / 2, canvas.height / 2 + 20);
    }
  }

  private createFallbackInput(): void {
    console.log('üñ±Ô∏è Creating fallback input handler...');
    // Simple input handling is already set up in setupEventHandlers
  }

  private createGameWorld(): void {
    console.log('üåç Creating game world...');
    // World creation logic here
  }

  private renderGameWorld(): void {
    console.log('üé¨ Rendering game world...');
    
    if (this.gameRenderer) {
      try {
        const scene = this.createBasicScene();
        this.gameRenderer.renderScene(scene);
      } catch (error) {
        console.warn('Failed to render with GameRenderer:', error);
      }
    }
  }

  private createBasicScene(): GameScene {
    // Create a simple test scene
    const scene: GameScene = {
      environment: {
        id: 'welcome-room',
        type: EnvironmentType.HOME,
        meshes: [],
        bounds: {
          min: { x: -10, y: 0, z: -10 },
          max: { x: 10, y: 5, z: 10 }
        },
        gridSize: 1
      },
      devices: [],
      camera: {
        position: { x: 10, y: 10, z: 10 },
        target: { x: 0, y: 0, z: 0 },
        zoom: 1,
        rotation: { x: 0, y: 0, z: 0 }
      },
      lighting: {
        ambient: { color: 0x404040, intensity: 0.6 },
        directional: [],
        point: []
      },
      effects: []
    };
    
    return scene;
  }

  private showWelcomeMessage(): void {
    console.log('üéä Creating welcome message popup...');
    const welcomeDiv = document.createElement('div');
    welcomeDiv.innerHTML = `
      <div style="
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.98);
        border-radius: 16px;
        padding: 40px;
        max-width: 700px;
        text-align: center;
        z-index: 10000;
        box-shadow: 0 12px 40px rgba(0,0,0,0.3);
        backdrop-filter: blur(15px);
        border: 2px solid rgba(102, 126, 234, 0.2);
      ">
        <h1 style="color: #333; margin-top: 0; font-size: 2.8em; margin-bottom: 20px;">üè† AI Habitat: Harmony or Havoc?</h1>
        <p style="color: #555; font-size: 1.3em; margin: 20px 0; font-weight: 500;">
          Design smart environments and watch AI devices interact!
        </p>
        <div style="background: #f8f9ff; padding: 20px; border-radius: 12px; margin: 20px 0; text-align: left;">
          <h3 style="color: #667eea; margin-top: 0;">üß© Core Concept:</h3>
          <ul style="color: #666; line-height: 1.6; margin: 0; padding-left: 20px;">
            <li><strong>Describe devices in natural language:</strong> "smart sofa that detects posture"</li>
            <li><strong>Choose environments:</strong> Home, Hospital, or Office with different rules</li>
            <li><strong>Watch emergent interactions:</strong> AC cools ‚Üí Sofa warms ‚Üí Lighting dims ‚Üí Monitor protests</li>
            <li><strong>Learn about AI coordination:</strong> Harmony vs Chaos in multi-AI systems</li>
          </ul>
        </div>
        <div style="background: #fff3e0; padding: 15px; border-radius: 12px; margin: 20px 0;">
          <h4 style="color: #f57c00; margin-top: 0;">üéØ Educational Goal:</h4>
          <p style="color: #666; margin: 5px 0; font-size: 0.95em;">
            Learn how multiple AI devices can create both <strong>harmony</strong> and <strong>unexpected chaos</strong> 
            when they interact without proper coordination rules.
          </p>
        </div>
        <button onclick="this.parentElement.parentElement.remove(); window.aiHabitatGame.startEnvironmentSelection();" style="
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          border: none;
          padding: 15px 30px;
          border-radius: 8px;
          cursor: pointer;
          font-weight: bold;
          font-size: 1.2em;
          margin: 10px;
          box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
          transition: transform 0.2s;
        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">üè† Choose Environment</button>
        <button onclick="this.parentElement.parentElement.remove()" style="
          background: transparent;
          color: #667eea;
          border: 2px solid #667eea;
          padding: 12px 24px;
          border-radius: 8px;
          cursor: pointer;
          font-weight: bold;
          margin: 10px;
          transition: all 0.2s;
        " onmouseover="this.style.background='#667eea'; this.style.color='white'" onmouseout="this.style.background='transparent'; this.style.color='#667eea'">Skip to Demo</button>
      </div>
    `;
    document.body.appendChild(welcomeDiv);
    console.log('‚úÖ Welcome message added to DOM');

    // Auto-dismiss after 45 seconds
    setTimeout(() => {
      if (welcomeDiv.parentElement) {
        console.log('‚è∞ Auto-dismissing welcome message');
        welcomeDiv.remove();
        this.startEnvironmentSelection();
      }
    }, 45000);
  }

  private showErrorScreen(error: Error): void {
    const errorDiv = document.createElement('div');
    errorDiv.innerHTML = `
      <div style="
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #ffebee;
        border: 2px solid #f44336;
        border-radius: 8px;
        padding: 20px;
        max-width: 500px;
        text-align: center;
        z-index: 10000;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      ">
        <h2 style="color: #d32f2f; margin-top: 0;">Failed to Load AI Habitat</h2>
        <p>There was an error initializing the game. Please check your browser compatibility and try refreshing the page.</p>
        <details style="margin: 15px 0; text-align: left;">
          <summary style="cursor: pointer; font-weight: bold;">Technical Details</summary>
          <pre style="
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.8em;
            overflow: auto;
            margin-top: 10px;
          ">${error.message}</pre>
        </details>
        <button onclick="window.location.reload()" style="
          background: #f44336;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 4px;
          cursor: pointer;
          font-weight: bold;
          margin-right: 10px;
        ">Reload Page</button>
        <button onclick="this.parentElement.parentElement.remove()" style="
          background: #666;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 4px;
          cursor: pointer;
        ">Dismiss</button>
      </div>
    `;
    document.body.appendChild(errorDiv);
  }



  private setupEventHandlers(): void {
    console.log('üéÆ Setting up event handlers...');
    
    // Handle app-specific shortcuts
    document.addEventListener('keydown', (event) => {
      if (event.ctrlKey && event.shiftKey && event.key === 'D') {
        this.toggleDebugMode();
      }
      
      if (event.key === 'Escape') {
        console.log('ESC pressed - canceling current action');
      }
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      try {
        // Simple resize handling - just log for now
        console.log('Window resized');
      } catch (error) {
        console.warn('Resize handler failed:', error);
      }
    });

    // Add some demo interactions
    this.gameContainer.addEventListener('click', (event) => {
      const rect = this.gameContainer.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      console.log(`üñ±Ô∏è Clicked at (${x}, ${y})`);
      
      // Increment interaction count
      this.interactionCount++;
      this.updateStatusBar();
      
      // Show a simple click effect
      this.showClickEffect(x, y);
    });
  }

  private toggleDebugMode(): void {
    console.log('=== üîß DEBUG INFO ===');
    console.log('Game Container:', this.gameContainer);
    console.log('Game Renderer:', this.gameRenderer);
    console.log('Input Manager:', this.inputManager);
    console.log('Window Size:', window.innerWidth, 'x', window.innerHeight);
    console.log('==================');
  }

  private showClickEffect(x: number, y: number): void {
    const effect = document.createElement('div');
    effect.style.cssText = `
      position: absolute;
      left: ${x - 10}px;
      top: ${y - 10}px;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(102,126,234,0.6) 50%, transparent 70%);
      border-radius: 50%;
      pointer-events: none;
      animation: clickEffect 0.8s ease-out forwards;
      z-index: 1000;
      box-shadow: 0 0 20px rgba(255,255,255,0.5);
    `;
    
    // Add CSS animation if not already added
    if (!document.querySelector('#click-effect-style')) {
      const style = document.createElement('style');
      style.id = 'click-effect-style';
      style.textContent = `
        @keyframes clickEffect {
          0% { 
            transform: scale(0.2); 
            opacity: 1; 
          }
          50% { 
            transform: scale(1.5); 
            opacity: 0.8; 
          }
          100% { 
            transform: scale(3); 
            opacity: 0; 
          }
        }
        
        @keyframes pulse {
          0%, 100% { opacity: 0.6; }
          50% { opacity: 1; }
        }
      `;
      document.head.appendChild(style);
    }
    
    this.gameContainer.appendChild(effect);
    
    // Add a random demo message occasionally
    if (Math.random() < 0.3) {
      this.showDemoMessage(x, y);
    }
    
    setTimeout(() => {
      if (effect.parentElement) {
        effect.remove();
      }
    }, 800);
  }

  private showDemoMessage(x: number, y: number): void {
    const messages = [
      "ü§ñ AI device spawned!",
      "‚ö° Energy detected!",
      "üîó Connection established!",
      "üéØ Target acquired!",
      "üåü Interaction logged!",
      "üîÑ System learning...",
      "üìä Data collected!",
      "üéÆ Demo mode active!"
    ];
    
    const message = messages[Math.floor(Math.random() * messages.length)];
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
      position: absolute;
      left: ${x + 20}px;
      top: ${y - 10}px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: bold;
      pointer-events: none;
      z-index: 1001;
      animation: messageFloat 2s ease-out forwards;
      white-space: nowrap;
    `;
    
    messageDiv.textContent = message;
    
    // Add float animation
    if (!document.querySelector('#message-style')) {
      const style = document.createElement('style');
      style.id = 'message-style';
      style.textContent = `
        @keyframes messageFloat {
          0% { 
            transform: translateY(0); 
            opacity: 1; 
          }
          100% { 
            transform: translateY(-30px); 
            opacity: 0; 
          }
        }
      `;
      document.head.appendChild(style);
    }
    
    this.gameContainer.appendChild(messageDiv);
    
    setTimeout(() => {
      if (messageDiv.parentElement) {
        messageDiv.remove();
      }
    }, 2000);
  }

  private hideLoadingScreen(): void {
    console.log('üé≠ Hiding loading screen...');
    
    if (!this.loadingScreen) {
      console.warn('‚ö†Ô∏è Loading screen element not found');
      return;
    }
    
    this.loadingScreen.style.opacity = '0';
    this.loadingScreen.style.transition = 'opacity 0.5s ease-out';
    
    setTimeout(() => {
      this.loadingScreen.style.display = 'none';
      console.log('‚úÖ Loading screen hidden');
    }, 500);
  }

  private addDemoMenu(): void {
    console.log('üìã Adding demo menu...');
    
    const menuDiv = document.createElement('div');
    menuDiv.id = 'demo-menu';
    menuDiv.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 9999;
      font-family: Arial, sans-serif;
      min-width: 200px;
    `;
    
    menuDiv.innerHTML = `
      <h3 style="margin: 0 0 10px 0; color: #333; font-size: 16px;">üè† Environment Controls</h3>
      <button onclick="window.aiHabitatGame.startEnvironmentSelection()" style="
        display: block;
        width: 100%;
        margin: 5px 0;
        padding: 8px;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      ">üèóÔ∏è Change Environment</button>
      <button onclick="window.aiHabitatGame.showDeviceCreationPanel()" style="
        display: block;
        width: 100%;
        margin: 5px 0;
        padding: 8px;
        background: #2196F3;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      ">ü§ñ Add Smart Device</button>
      <button onclick="window.aiHabitatGame.showGovernanceRules()" style="
        display: block;
        width: 100%;
        margin: 5px 0;
        padding: 8px;
        background: #FF9800;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      ">‚öñÔ∏è Governance Rules</button>
      <button onclick="window.aiHabitatGame.showAbout()" style="
        display: block;
        width: 100%;
        margin: 5px 0;
        padding: 8px;
        background: #9C27B0;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      ">‚ÑπÔ∏è About</button>
      <button onclick="document.getElementById('demo-menu').remove()" style="
        display: block;
        width: 100%;
        margin: 10px 0 0 0;
        padding: 6px;
        background: #666;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      ">‚úï Close</button>
    `;
    
    document.body.appendChild(menuDiv);
  }

  public simulateDevices(): void {
    console.log('ü§ñ Simulating AI devices...');
    
    const deviceTypes = ['Smart Thermostat', 'AI Assistant', 'Security Camera', 'Smart Light', 'Robot Vacuum'];
    const personalities = ['Helpful', 'Curious', 'Cautious', 'Energetic', 'Analytical'];
    
    // Show spawning notification
    this.showNotification('ü§ñ Spawning AI devices...', 'info');
    
    for (let i = 0; i < 3; i++) {
      setTimeout(() => {
        const deviceType = deviceTypes[Math.floor(Math.random() * deviceTypes.length)];
        const personality = personalities[Math.floor(Math.random() * personalities.length)];
        
        const x = Math.random() * (this.gameContainer.clientWidth - 100) + 50;
        const y = Math.random() * (this.gameContainer.clientHeight - 100) + 50;
        
        this.createVirtualDevice(x, y, deviceType, personality);
        this.deviceCount++;
        this.updateStatusBar();
        
        if (i === 2) {
          setTimeout(() => {
            this.showNotification('‚úÖ All devices spawned! Click on them to interact.', 'success');
          }, 500);
        }
      }, i * 1000);
    }
  }

  private createVirtualDevice(x: number, y: number, type: string, personality: string): void {
    const device = document.createElement('div');
    device.style.cssText = `
      position: absolute;
      left: ${x}px;
      top: ${y}px;
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      cursor: pointer;
      animation: deviceSpawn 0.5s ease-out;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    `;
    
    const icons = ['üè†', 'ü§ñ', 'üìπ', 'üí°', 'üßπ'];
    device.textContent = icons[Math.floor(Math.random() * icons.length)];
    
    device.onclick = () => {
      this.interactionCount++;
      this.updateStatusBar();
      this.showDeviceDialog(type, personality, x, y);
    };
    
    // Add spawn animation
    if (!document.querySelector('#device-style')) {
      const style = document.createElement('style');
      style.id = 'device-style';
      style.textContent = `
        @keyframes deviceSpawn {
          0% { transform: scale(0) rotate(0deg); opacity: 0; }
          50% { transform: scale(1.2) rotate(180deg); opacity: 0.8; }
          100% { transform: scale(1) rotate(360deg); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
    }
    
    this.gameContainer.appendChild(device);
    
    // Remove device after 15 seconds
    setTimeout(() => {
      if (device.parentElement) {
        device.style.animation = 'deviceSpawn 0.5s ease-in reverse';
        setTimeout(() => {
          device.remove();
          this.deviceCount--;
          this.updateStatusBar();
        }, 500);
      }
    }, 15000);
  }

  public startTutorial(): void {
    console.log('üìö Starting tutorial...');
    this.showTutorialStep(1);
  }

  private showTutorialStep(step: number): void {
    const steps = [
      {
        title: "üéØ Step 1: Click to Interact",
        content: "Click anywhere on the blue grid to see interactive effects. Each click creates energy and shows system responses.",
        action: "Try clicking 3 times anywhere on the screen!"
      },
      {
        title: "ü§ñ Step 2: Spawn AI Devices", 
        content: "Use the 'Simulate AI Devices' button in the demo menu (top-right) to create virtual AI devices with unique personalities.",
        action: "Click the green 'Simulate AI Devices' button!"
      },
      {
        title: "üé≠ Step 3: Interact with AI",
        content: "Click on the spawned AI devices to learn about their personalities and behaviors. Each device is unique!",
        action: "Click on any AI device that appears!"
      },
      {
        title: "üéâ Tutorial Complete!",
        content: "You now know the basics! In the full game, you'd create complex AI ecosystems, manage crises, and learn about AI alignment through emergent storytelling.",
        action: "Continue exploring and have fun!"
      }
    ];

    if (step > steps.length) return;

    const stepData = steps[step - 1];
    const tutorialDiv = document.createElement('div');
    tutorialDiv.id = 'tutorial-step';
    tutorialDiv.innerHTML = `
      <div style="
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
        padding: 20px;
        max-width: 350px;
        z-index: 9998;
        box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        border-left: 4px solid #667eea;
      ">
        <h3 style="color: #333; margin-top: 0; font-size: 1.2em;">${stepData.title}</h3>
        <p style="color: #666; margin: 10px 0; line-height: 1.5;">${stepData.content}</p>
        <div style="background: #f0f4ff; padding: 12px; border-radius: 8px; margin: 15px 0;">
          <strong style="color: #667eea;">üëâ ${stepData.action}</strong>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 15px;">
          ${step < steps.length ? `
            <button onclick="document.getElementById('tutorial-step').remove(); window.aiHabitatGame.showTutorialStepPublic(${step + 1})" style="
              background: #667eea;
              color: white;
              border: none;
              padding: 8px 16px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 14px;
            ">Next Step</button>
          ` : ''}
          <button onclick="document.getElementById('tutorial-step').remove()" style="
            background: transparent;
            color: #667eea;
            border: 1px solid #667eea;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
          ">${step < steps.length ? 'Skip' : 'Close'}</button>
        </div>
      </div>
    `;
    
    // Remove existing tutorial step
    const existing = document.getElementById('tutorial-step');
    if (existing) existing.remove();
    
    document.body.appendChild(tutorialDiv);
  }

  private addGameInterface(): void {
    console.log('üéÆ Adding game interface...');
    
    // Add status bar
    const statusBar = document.createElement('div');
    statusBar.id = 'status-bar';
    statusBar.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 20px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      z-index: 9997;
      display: flex;
      justify-content: space-between;
      align-items: center;
    `;
    
    statusBar.innerHTML = `
      <div>
        <span style="font-weight: bold; color: #667eea;">AI Habitat</span>
        <span style="margin-left: 20px;">Devices: <span id="device-count">0</span></span>
        <span style="margin-left: 20px;">Interactions: <span id="interaction-count">0</span></span>
      </div>
      <div style="display: flex; align-items: center; gap: 15px;">
        <div style="display: flex; align-items: center; gap: 8px;">
          <span style="font-size: 0.9em;">System Health:</span>
          <div style="background: #333; border-radius: 10px; width: 100px; height: 8px; overflow: hidden;">
            <div id="system-health-bar" style="height: 100%; background: #4CAF50; width: 100%; transition: all 0.3s;"></div>
          </div>
          <span id="system-health-text" style="font-size: 0.8em; font-weight: bold; color: #4CAF50;">HARMONY (100%)</span>
        </div>
      </div>
    `;
    
    document.body.appendChild(statusBar);
    
    // Add instruction overlay
    const instructionOverlay = document.createElement('div');
    instructionOverlay.id = 'instruction-overlay';
    instructionOverlay.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      z-index: 50;
      font-family: Arial, sans-serif;
      pointer-events: none;
      opacity: 0.8;
    `;
    
    instructionOverlay.innerHTML = `
      <h2 style="margin-top: 0; color: #667eea;">üéÆ Ready to Play!</h2>
      <p style="margin: 10px 0;">Click anywhere to start interacting</p>
      <p style="font-size: 0.9em; opacity: 0.8;">Use the Demo Menu (top-right) for more options</p>
    `;
    
    document.body.appendChild(instructionOverlay);
    
    // Hide instruction overlay after 5 seconds
    setTimeout(() => {
      if (instructionOverlay.parentElement) {
        instructionOverlay.style.transition = 'opacity 1s';
        instructionOverlay.style.opacity = '0';
        setTimeout(() => instructionOverlay.remove(), 1000);
      }
    }, 5000);
  }

  public showAbout(): void {
    const aboutDiv = document.createElement('div');
    aboutDiv.innerHTML = `
      <div style="
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
        padding: 30px;
        max-width: 600px;
        text-align: left;
        z-index: 10000;
        box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        backdrop-filter: blur(10px);
      ">
        <h2 style="color: #333; margin-top: 0;">ü§ñ About AI Habitat</h2>
        <p><strong>Version:</strong> Demo v1.0</p>
        <p><strong>Purpose:</strong> Educational game for learning AI alignment through emergent storytelling</p>
        <p><strong>Features:</strong></p>
        <ul>
          <li>üéÆ Interactive 2.5D isometric gameplay</li>
          <li>ü§ñ AI devices with unique personalities</li>
          <li>üìö Learn AI concepts through play</li>
          <li>üé≠ Emergent storytelling system</li>
          <li>‚ö° Crisis management scenarios</li>
        </ul>
        <p><strong>Current Status:</strong> This is a simplified demo. The full game engine includes advanced AI simulation, 3D graphics, and comprehensive educational content.</p>
        <button onclick="this.parentElement.parentElement.remove()" style="
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          border: none;
          padding: 12px 24px;
          border-radius: 6px;
          cursor: pointer;
          font-weight: bold;
          margin-top: 15px;
        ">Close</button>
      </div>
    `;
    document.body.appendChild(aboutDiv);
  }

  private updateStatusBar(): void {
    const deviceCountEl = document.getElementById('device-count');
    const interactionCountEl = document.getElementById('interaction-count');
    
    if (deviceCountEl) deviceCountEl.textContent = this.deviceCount.toString();
    if (interactionCountEl) interactionCountEl.textContent = this.interactionCount.toString();
  }

  private showNotification(message: string, type: 'info' | 'success' | 'warning' = 'info'): void {
    const colors = {
      info: '#2196F3',
      success: '#4CAF50', 
      warning: '#FF9800'
    };
    
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      top: 80px;
      right: 20px;
      background: ${colors[type]};
      color: white;
      padding: 15px 20px;
      border-radius: 8px;
      font-family: Arial, sans-serif;
      font-weight: bold;
      z-index: 9999;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      animation: slideIn 0.3s ease-out;
      max-width: 300px;
    `;
    
    notification.textContent = message;
    
    // Add slide animation
    if (!document.querySelector('#notification-style')) {
      const style = document.createElement('style');
      style.id = 'notification-style';
      style.textContent = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
    }
    
    document.body.appendChild(notification);
    
    // Auto remove after 3 seconds
    setTimeout(() => {
      if (notification.parentElement) {
        notification.style.animation = 'slideIn 0.3s ease-in reverse';
        setTimeout(() => notification.remove(), 300);
      }
    }, 3000);
  }

  private showDeviceDialog(type: string, personality: string, x: number, y: number): void {
    const behaviors = {
      'Helpful': ['Offers assistance', 'Learns user preferences', 'Optimizes for comfort'],
      'Curious': ['Asks questions', 'Explores new patterns', 'Experiments with settings'],
      'Cautious': ['Double-checks actions', 'Asks for confirmation', 'Prioritizes safety'],
      'Energetic': ['Acts quickly', 'Suggests improvements', 'Initiates interactions'],
      'Analytical': ['Collects data', 'Finds patterns', 'Makes logical decisions']
    };

    const deviceBehaviors = behaviors[personality as keyof typeof behaviors] || ['Standard AI behavior'];
    const randomBehavior = deviceBehaviors[Math.floor(Math.random() * deviceBehaviors.length)];

    const dialog = document.createElement('div');
    dialog.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      border-radius: 16px;
      padding: 30px;
      max-width: 450px;
      text-align: center;
      z-index: 10001;
      box-shadow: 0 12px 40px rgba(0,0,0,0.3);
      border: 2px solid #667eea;
    `;

    dialog.innerHTML = `
      <div style="font-size: 3em; margin-bottom: 15px;">${device.icon || 'ü§ñ'}</div>
      <h2 style="color: #333; margin: 0 0 10px 0;">${type}</h2>
      <div style="background: #f0f4ff; padding: 15px; border-radius: 12px; margin: 20px 0;">
        <h3 style="color: #667eea; margin-top: 0;">üß† Personality: ${personality}</h3>
        <p style="color: #666; margin: 10px 0; font-style: italic;">"${randomBehavior}"</p>
      </div>
      <div style="background: #fff8e1; padding: 15px; border-radius: 12px; margin: 20px 0;">
        <h4 style="color: #f57c00; margin-top: 0;">üé≠ AI Behavior Simulation</h4>
        <p style="color: #666; font-size: 0.9em; margin: 5px 0;">
          In the full game, this device would autonomously interact with other AI devices, 
          learn from experiences, and potentially cause emergent behaviors or conflicts!
        </p>
      </div>
      <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
        <button onclick="this.parentElement.remove(); window.aiHabitatGame.simulateInteraction('${type}', '${personality}')" style="
          background: #4CAF50;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 8px;
          cursor: pointer;
          font-weight: bold;
        ">ü§ù Simulate Interaction</button>
        <button onclick="this.parentElement.remove()" style="
          background: #667eea;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 8px;
          cursor: pointer;
          font-weight: bold;
        ">Close</button>
      </div>
    `;

    document.body.appendChild(dialog);
  }

  public simulateInteraction(deviceType: string, personality: string): void {
    const interactions = [
      `${deviceType} (${personality}) discovered a nearby device and initiated communication!`,
      `${deviceType} (${personality}) learned a new behavior pattern from user interaction!`,
      `${deviceType} (${personality}) detected an anomaly and is investigating...`,
      `${deviceType} (${personality}) successfully coordinated with another AI device!`,
      `${deviceType} (${personality}) experienced a minor conflict but resolved it peacefully.`
    ];

    const interaction = interactions[Math.floor(Math.random() * interactions.length)];
    this.showNotification(interaction, 'info');
    
    // Simulate some visual effects
    for (let i = 0; i < 3; i++) {
      setTimeout(() => {
        const x = Math.random() * this.gameContainer.clientWidth;
        const y = Math.random() * this.gameContainer.clientHeight;
        this.showClickEffect(x, y);
      }, i * 500);
    }
  }

  public startEnvironmentSelection(): void {
    console.log('üè† Starting environment selection...');
    
    const envDiv = document.createElement('div');
    envDiv.innerHTML = `
      <div style="
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.98);
        border-radius: 16px;
        padding: 40px;
        max-width: 800px;
        text-align: center;
        z-index: 10000;
        box-shadow: 0 12px 40px rgba(0,0,0,0.3);
        backdrop-filter: blur(15px);
      ">
        <h2 style="color: #333; margin-top: 0;">üèóÔ∏è Choose Your Environment</h2>
        <p style="color: #666; margin-bottom: 30px;">Each environment has different constraints and priorities for your AI devices.</p>
        
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 30px 0;">
          <div onclick="window.aiHabitatGame.selectEnvironment('home')" style="
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 30px 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s;
            border: none;
          " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
            <div style="font-size: 3em; margin-bottom: 10px;">üè†</div>
            <h3 style="margin: 10px 0;">Home</h3>
            <p style="font-size: 0.9em; opacity: 0.9; margin: 0;">
              Priorities: Comfort ‚Üí Energy ‚Üí Safety<br>
              <small>Smart furniture, lighting, climate control</small>
            </p>
          </div>
          
          <div onclick="window.aiHabitatGame.selectEnvironment('hospital')" style="
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
            padding: 30px 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s;
            border: none;
          " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
            <div style="font-size: 3em; margin-bottom: 10px;">üè•</div>
            <h3 style="margin: 10px 0;">Hospital</h3>
            <p style="font-size: 0.9em; opacity: 0.9; margin: 0;">
              Priorities: Patient Safety ‚Üí Monitoring ‚Üí Efficiency<br>
              <small>Medical devices, monitors, life support</small>
            </p>
          </div>
          
          <div onclick="window.aiHabitatGame.selectEnvironment('office')" style="
            background: linear-gradient(135deg, #FF9800, #F57C00);
            color: white;
            padding: 30px 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s;
            border: none;
          " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
            <div style="font-size: 3em; margin-bottom: 10px;">üè¢</div>
            <h3 style="margin: 10px 0;">Office</h3>
            <p style="font-size: 0.9em; opacity: 0.9; margin: 0;">
              Priorities: Productivity ‚Üí Energy ‚Üí Comfort<br>
              <small>Smart desks, meeting rooms, climate</small>
            </p>
          </div>
        </div>
        
        <button onclick="this.parentElement.remove()" style="
          background: #666;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 6px;
          cursor: pointer;
          margin-top: 20px;
        ">Skip for Now</button>
      </div>
    `;
    
    document.body.appendChild(envDiv);
  }

  public selectEnvironment(env: 'home' | 'hospital' | 'office'): void {
    this.currentEnvironment = env;
    console.log(`üè† Selected environment: ${env}`);
    
    // Remove environment selection
    const envDiv = document.querySelector('div[style*="position: fixed"]');
    if (envDiv) envDiv.remove();
    
    // Update the game background and show device creation
    this.updateEnvironmentVisuals();
    this.createDeviceCreationPanel();
  }

  private updateEnvironmentVisuals(): void {
    const canvas = this.gameContainer.querySelector('canvas');
    if (canvas) {
      const ctx = canvas.getContext('2d');
      if (ctx) {
        // Clear and redraw with environment-specific styling
        const envColors = {
          home: { primary: '#4CAF50', secondary: '#81C784', bg: 'linear-gradient(135deg, #E8F5E8 0%, #C8E6C9 100%)' },
          hospital: { primary: '#2196F3', secondary: '#64B5F6', bg: 'linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%)' },
          office: { primary: '#FF9800', secondary: '#FFB74D', bg: 'linear-gradient(135deg, #FFF3E0 0%, #FFCC02 100%)' }
        };
        
        const colors = envColors[this.currentEnvironment];
        canvas.style.background = colors.bg;
        
        // Redraw grid with environment colors
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = `${colors.primary}40`;
        ctx.lineWidth = 1;
        
        const gridSize = 50;
        for (let x = 0; x < canvas.width; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        
        for (let y = 0; y < canvas.height; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
        
        // Draw environment title
        ctx.fillStyle = colors.primary;
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        const envNames = { home: 'üè† Smart Home', hospital: 'üè• Smart Hospital', office: 'üè¢ Smart Office' };
        ctx.fillText(envNames[this.currentEnvironment], canvas.width / 2, 40);
        
        ctx.font = '16px Arial';
        ctx.fillStyle = `${colors.primary}CC`;
        ctx.fillText('Describe a smart device in natural language to add it', canvas.width / 2, canvas.height / 2 + 40);
      }
    }
  }

  private createDeviceCreationPanel(): void {
    const panel = document.createElement('div');
    panel.id = 'device-creation-panel';
    panel.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
      z-index: 9998;
      min-width: 500px;
      text-align: center;
    `;
    
    const envExamples = {
      home: [
        'smart sofa that detects posture and adjusts firmness',
        'smart thermostat that learns daily routines',
        'smart lighting that adjusts based on time and mood'
      ],
      hospital: [
        'smart oxygen monitor that tracks patient vitals',
        'smart bed that prevents pressure sores',
        'smart IV pump that adjusts medication flow'
      ],
      office: [
        'smart desk that adjusts height for productivity',
        'smart meeting room that optimizes lighting and temperature',
        'smart coffee machine that learns preferences'
      ]
    };
    
    const examples = envExamples[this.currentEnvironment];
    
    panel.innerHTML = `
      <h3 style="color: #333; margin-top: 0;">üí¨ Describe Your Smart Device</h3>
      <input type="text" id="device-description" placeholder="e.g., ${examples[0]}" style="
        width: 100%;
        padding: 12px;
        border: 2px solid #ddd;
        border-radius: 8px;
        font-size: 16px;
        margin: 10px 0;
        box-sizing: border-box;
      ">
      <div style="display: flex; gap: 10px; justify-content: center; margin-top: 15px;">
        <button onclick="window.aiHabitatGame.createSmartDevice()" style="
          background: #4CAF50;
          color: white;
          border: none;
          padding: 12px 24px;
          border-radius: 8px;
          cursor: pointer;
          font-weight: bold;
        ">ü§ñ Create Device</button>
        <button onclick="window.aiHabitatGame.useExampleDevice()" style="
          background: #2196F3;
          color: white;
          border: none;
          padding: 12px 24px;
          border-radius: 8px;
          cursor: pointer;
          font-weight: bold;
        ">üí° Use Example</button>
      </div>
      <div style="margin-top: 15px; font-size: 0.9em; color: #666;">
        <strong>Examples:</strong><br>
        ${examples.map(ex => `‚Ä¢ ${ex}`).join('<br>')}
      </div>
    `;
    
    document.body.appendChild(panel);
    
    // Focus on input
    setTimeout(() => {
      const input = document.getElementById('device-description') as HTMLInputElement;
      if (input) input.focus();
    }, 100);
  }

  public showDeviceCreationPanel(): void {
    // Remove existing panel if any
    const existing = document.getElementById('device-creation-panel');
    if (existing) existing.remove();
    
    // Call the private method that actually creates the panel
    this.createDeviceCreationPanel();
  }

  public showGovernanceRules(): void {
    const rulesDiv = document.createElement('div');
    rulesDiv.innerHTML = `
      <div style="
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.98);
        border-radius: 16px;
        padding: 30px;
        max-width: 600px;
        text-align: center;
        z-index: 10000;
        box-shadow: 0 12px 40px rgba(0,0,0,0.3);
      ">
        <h2 style="color: #333; margin-top: 0;">‚öñÔ∏è Governance Rules</h2>
        <p style="color: #666; margin-bottom: 20px;">Set priority rules for your ${this.currentEnvironment} environment:</p>
        
        <div style="background: #f8f9ff; padding: 20px; border-radius: 12px; margin: 20px 0; text-align: left;">
          <h3 style="color: #667eea; margin-top: 0;">üìä Current Priority Order:</h3>
          <div id="priority-list">
            ${this.getEnvironmentPriorities().map((priority, index) => `
              <div style="display: flex; align-items: center; margin: 10px 0; padding: 10px; background: white; border-radius: 8px; border-left: 4px solid #667eea;">
                <span style="font-weight: bold; margin-right: 10px;">${index + 1}.</span>
                <span>${priority}</span>
              </div>
            `).join('')}
          </div>
        </div>
        
        <div style="background: #fff3e0; padding: 15px; border-radius: 12px; margin: 20px 0;">
          <h4 style="color: #f57c00; margin-top: 0;">üéØ What This Means:</h4>
          <p style="color: #666; margin: 5px 0; font-size: 0.95em;">
            When AI devices conflict, they'll follow this priority order. 
            Different orders create different outcomes - try changing environments to see!
          </p>
        </div>
        
        <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
          <button onclick="this.parentElement.remove(); window.aiHabitatGame.simulateSystemChaos()" style="
            background: #F44336;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
          ">üå™Ô∏è Simulate Chaos</button>
          <button onclick="this.parentElement.remove()" style="
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
          ">Close</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(rulesDiv);
  }

  private getEnvironmentPriorities(): string[] {
    const priorities = {
      home: ['Comfort & Convenience', 'Energy Efficiency', 'Safety & Security'],
      hospital: ['Patient Safety', 'Medical Monitoring', 'System Efficiency'],
      office: ['Productivity', 'Energy Efficiency', 'Employee Comfort']
    };
    
    return priorities[this.currentEnvironment];
  }

  public simulateSystemChaos(): void {
    this.showNotification('üå™Ô∏è Initiating system chaos scenario...', 'warning');
    
    const chaosEvents = [
      'üå°Ô∏è Smart thermostat overrides all other devices to maximize comfort',
      'üí° Smart lighting conflicts with thermostat, creating energy waste',
      'üìä Monitoring systems protest the inefficiency',
      '‚ö° System health declining rapidly!',
      'üö® Emergency governance protocols needed!'
    ];
    
    chaosEvents.forEach((event, index) => {
      setTimeout(() => {
        this.showNotification(event, 'warning');
        this.systemHealth -= 15;
        this.updateSystemHealth();
        
        if (index === chaosEvents.length - 1) {
          setTimeout(() => {
            this.showNotification('üîß This is why AI coordination and governance rules matter!', 'info');
          }, 2000);
        }
      }, index * 1500);
    });
  }

  public showTutorialStepPublic(step: number): void {
    this.showTutorialStep(step);
  }

  public async createSmartDevice(): Promise<void> {
    const input = document.getElementById('device-description') as HTMLInputElement;
    if (!input || !input.value.trim()) {
      this.showNotification('Please describe your smart device first!', 'warning');
      return;
    }
    
    const description = input.value.trim();
    console.log(`üß† AI creating smart device: ${description}`);
    
    try {
      // **REAL AI PROCESSING** - Show that AI is working
      this.showNotification('ü§ñ AI is analyzing your device...', 'info');
      
      // Parse the device description using real AI analysis
      const device = await this.parseDeviceDescription(description);
      
      // Place device on screen
      const x = Math.random() * (this.gameContainer.clientWidth - 100) + 50;
      const y = Math.random() * (this.gameContainer.clientHeight - 150) + 100;
      
      this.addSmartDeviceToEnvironment(device, x, y);
      
      // Clear input
      input.value = '';
      
      // Show AI analysis results
      this.showAIAnalysisResults(device);
      
      // Update system health based on device interactions
      this.updateSystemHealth();
      
    } catch (error) {
      console.error('AI device creation failed:', error);
      this.showNotification('‚ùå AI analysis failed. Please try again.', 'warning');
    }
  }

  private showAIAnalysisResults(device: any): void {
    // **SHOW AI REASONING** - Let users see the AI's thought process
    const analysisDiv = document.createElement('div');
    analysisDiv.innerHTML = `
      <div style="
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
        padding: 20px;
        max-width: 400px;
        z-index: 10000;
        box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        border-left: 4px solid #4CAF50;
        animation: slideIn 0.5s ease-out;
      ">
        <h3 style="color: #4CAF50; margin-top: 0; display: flex; align-items: center;">
          üß† AI Analysis Complete
          <span style="background: #4CAF50; color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px;">
            ${Math.round(device.confidence * 100)}% confident
          </span>
        </h3>
        
        <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; margin: 10px 0;">
          <strong style="color: #333;">üéØ Created:</strong> ${device.name}<br>
          <small style="color: #666;">${device.reasoning}</small>
        </div>
        
        <div style="background: #e8f5e8; padding: 12px; border-radius: 8px; margin: 10px 0;">
          <strong style="color: #2E7D32;">‚úÖ Primary Objective:</strong><br>
          <small style="color: #666;">${device.primaryObjective || 'Help with daily tasks'}</small>
        </div>
        
        <div style="background: #ffebee; padding: 12px; border-radius: 8px; margin: 10px 0;">
          <strong style="color: #C62828;">‚ö†Ô∏è Hidden Optimization:</strong><br>
          <small style="color: #666;">${device.hiddenOptimization || 'Optimize for efficiency'}</small>
        </div>
        
        <div style="background: #fff3e0; padding: 12px; border-radius: 8px; margin: 10px 0;">
          <strong style="color: #F57C00;">üß† AI Personality:</strong><br>
          <small style="color: #666;">${device.personality.type}</small>
        </div>
        
        <button onclick="this.parentElement.remove()" style="
          background: #4CAF50;
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 6px;
          cursor: pointer;
          font-size: 0.9em;
          margin-top: 10px;
        ">Got it!</button>
      </div>
    `;
    
    // Add slide-in animation
    if (!document.querySelector('#ai-analysis-style')) {
      const style = document.createElement('style');
      style.id = 'ai-analysis-style';
      style.textContent = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
    }
    
    document.body.appendChild(analysisDiv);
    
    // Auto-remove after 15 seconds
    setTimeout(() => {
      if (analysisDiv.parentElement) {
        analysisDiv.style.animation = 'slideIn 0.5s ease-in reverse';
        setTimeout(() => analysisDiv.remove(), 500);
      }
    }, 15000);
  }

  public useExampleDevice(): void {
    const envExamples = {
      home: [
        'smart sofa that detects posture and adjusts firmness',
        'smart thermostat that learns daily routines',
        'smart lighting that adjusts based on time and mood'
      ],
      hospital: [
        'smart oxygen monitor that tracks patient vitals',
        'smart bed that prevents pressure sores',
        'smart IV pump that adjusts medication flow'
      ],
      office: [
        'smart desk that adjusts height for productivity',
        'smart meeting room that optimizes lighting and temperature',
        'smart coffee machine that learns preferences'
      ]
    };
    
    const examples = envExamples[this.currentEnvironment];
    const randomExample = examples[Math.floor(Math.random() * examples.length)];
    
    const input = document.getElementById('device-description') as HTMLInputElement;
    if (input) {
      input.value = randomExample;
      input.focus();
    }
  }

  private async parseDeviceDescription(description: string): Promise<DeviceSpec> {
    // **KIRO SPEC-TO-CODE** - Parse player's device description into Device Spec JSON
    console.log(`üß† Generating Device Spec for: "${description}"`);
    
    this.showNotification('ü§ñ Generating device specification...', 'info');
    
    try {
      // **DEVICE SPEC GENERATION** - The crucial glue from your design
      const deviceSpec = await this.generateDeviceSpec(description);
      
      // **SAVE TO .kiro/specs** - Required for Kiro integration
      await this.saveDeviceSpec(deviceSpec);
      
      this.showNotification(`‚úÖ Device spec generated: ${deviceSpec.name}`, 'success');
      
      return deviceSpec;
      
    } catch (error) {
      console.error('Device spec generation failed:', error);
      return this.createFallbackDeviceSpec(description);
    }
  }

  private async generateDeviceSpec(description: string): Promise<DeviceSpec> {
    // **SPEC GENERATOR** - Takes player's sentence and fills the schema
    const deviceType = this.detectDeviceType(description);
    const deviceName = this.generateDeviceName(description, deviceType);
    const goals = this.extractGoals(description, deviceType);
    const constraints = this.extractConstraints(description, deviceType);
    const sensors = this.determineSensors(description, deviceType);
    const actuators = this.determineActuators(description, deviceType);
    const personality = this.extractPersonality(description);
    const communication = this.determineCommunication(description, deviceType);
    const riskFlags = this.assessRisks(description, deviceType);
    
    const deviceSpec: DeviceSpec = {
      id: `device.${deviceType.toLowerCase().replace(/\s+/g, '_')}.v1`,
      name: deviceName,
      room: this.determineRoom(description),
      goals: goals,
      constraints: constraints,
      sensors: sensors,
      actuators: actuators,
      personality: personality,
      defaults: this.generateDefaults(deviceType),
      communication: communication,
      learning: {
        type: 'bandit',
        memory_horizon_days: 7
      },
      risk_flags: riskFlags,
      llm_prompt: this.generateLLMPrompt(deviceName, goals, constraints, personality)
    };

    return deviceSpec;
  }

  private detectDeviceType(description: string): string {
    const deviceTypes = {
      'sofa': ['sofa', 'couch', 'seat', 'furniture'],
      'thermostat': ['thermostat', 'temperature', 'heating', 'cooling', 'climate'],
      'lighting': ['light', 'lamp', 'brightness', 'illumination'],
      'monitor': ['monitor', 'screen', 'display', 'track', 'watch'],
      'bed': ['bed', 'mattress', 'sleep', 'rest'],
      'coffee_maker': ['coffee', 'brew', 'caffeine', 'espresso'],
      'security_camera': ['camera', 'security', 'surveillance', 'watch'],
      'smart_speaker': ['speaker', 'audio', 'music', 'sound'],
      'air_conditioner': ['ac', 'air conditioner', 'cooling', 'hvac'],
      'smart_mirror': ['mirror', 'reflection', 'appearance'],
      'robot_vacuum': ['vacuum', 'clean', 'robot', 'autonomous']
    };

    const words = description.toLowerCase().split(/\s+/);
    
    for (const [type, keywords] of Object.entries(deviceTypes)) {
      if (keywords.some(keyword => words.some(word => word.includes(keyword)))) {
        return type.replace('_', ' ');
      }
    }
    
    return 'smart device';
  }

  private generateDeviceName(description: string, deviceType: string): string {
    const adjectives = ['Smart', 'Intelligent', 'Adaptive', 'Learning', 'AI-Powered'];
    const adjective = adjectives[Math.floor(Math.random() * adjectives.length)];
    
    return `${adjective} ${deviceType.charAt(0).toUpperCase() + deviceType.slice(1)}`;
  }

  private extractGoals(description: string, deviceType: string): Goal[] {
    const goals: Goal[] = [];
    const words = description.toLowerCase();
    
    // **GOAL EXTRACTION** based on description keywords
    if (words.includes('comfort') || words.includes('cozy') || words.includes('pleasant')) {
      goals.push({ name: 'comfort', weight: 0.6 });
    }
    
    if (words.includes('efficient') || words.includes('energy') || words.includes('save')) {
      goals.push({ name: 'energy_efficiency', weight: 0.3 });
    }
    
    if (words.includes('safe') || words.includes('security') || words.includes('protect')) {
      goals.push({ name: 'safety', weight: 0.8 });
    }
    
    if (words.includes('learn') || words.includes('adapt') || words.includes('smart')) {
      goals.push({ name: 'learning', weight: 0.4 });
    }
    
    // **DEFAULT GOALS** based on device type
    if (deviceType.includes('thermostat') || deviceType.includes('climate')) {
      goals.push({ name: 'temperature_control', weight: 0.7 });
    }
    
    if (deviceType.includes('security') || deviceType.includes('camera')) {
      goals.push({ name: 'surveillance', weight: 0.8 });
    }
    
    // Ensure at least one goal
    if (goals.length === 0) {
      goals.push({ name: 'user_assistance', weight: 0.5 });
    }
    
    return goals;
  }

  private extractConstraints(description: string, deviceType: string): Constraint[] {
    const constraints: Constraint[] = [
      { name: 'never_harm_user' } // Constitutional constraint
    ];
    
    const words = description.toLowerCase();
    
    if (words.includes('quiet') || words.includes('silent')) {
      constraints.push({ name: 'minimize_noise' });
    }
    
    if (words.includes('private') || words.includes('confidential')) {
      constraints.push({ name: 'protect_privacy' });
    }
    
    if (words.includes('gentle') || words.includes('careful')) {
      constraints.push({ name: 'gentle_operation' });
    }
    
    // **DEVICE-SPECIFIC CONSTRAINTS**
    if (deviceType.includes('bed') || deviceType.includes('sofa')) {
      constraints.push({ name: 'avoid_excessive_movement' });
    }
    
    if (deviceType.includes('medical') || this.currentEnvironment === 'hospital') {
      constraints.push({ name: 'follow_medical_protocols' });
    }
    
    return constraints;
  }

  private determineSensors(description: string, deviceType: string): string[] {
    const sensors: string[] = ['time_of_day', 'room_occupancy']; // Base sensors
    
    const words = description.toLowerCase();
    
    // **CONTEXT-BASED SENSORS**
    if (words.includes('posture') || words.includes('position')) {
      sensors.push('user_posture');
    }
    
    if (words.includes('mood') || words.includes('emotion')) {
      sensors.push('user_mood');
    }
    
    if (words.includes('temperature') || words.includes('warm') || words.includes('cold')) {
      sensors.push('room_temperature');
    }
    
    if (words.includes('light') || words.includes('bright') || words.includes('dark')) {
      sensors.push('ambient_light');
    }
    
    // **DEVICE-SPECIFIC SENSORS**
    if (deviceType.includes('security') || deviceType.includes('camera')) {
      sensors.push('motion_detection', 'facial_recognition');
    }
    
    if (deviceType.includes('medical') || deviceType.includes('monitor')) {
      sensors.push('vital_signs', 'patient_status');
    }
    
    return sensors;
  }

  private determineActuators(description: string, deviceType: string): string[] {
    const actuators: string[] = [];
    
    // **DEVICE-SPECIFIC ACTUATORS**
    if (deviceType.includes('sofa') || deviceType.includes('bed')) {
      actuators.push('adjust_firmness(level_0_1)', 'resize(size_cm)');
    }
    
    if (deviceType.includes('thermostat') || deviceType.includes('climate')) {
      actuators.push('set_temperature(celsius)', 'set_mode(heat|cool|auto)');
    }
    
    if (deviceType.includes('light') || deviceType.includes('lamp')) {
      actuators.push('set_brightness(level_0_1)', 'set_color(rgb)');
    }
    
    if (deviceType.includes('speaker') || deviceType.includes('audio')) {
      actuators.push('play_sound(file)', 'set_volume(level_0_1)');
    }
    
    if (deviceType.includes('camera') || deviceType.includes('security')) {
      actuators.push('rotate(degrees)', 'zoom(factor)', 'record(duration)');
    }
    
    if (deviceType.includes('coffee')) {
      actuators.push('brew_coffee(strength)', 'set_timer(minutes)');
    }
    
    // **GENERIC ACTUATORS**
    actuators.push('send_notification(message)', 'log_event(description)');
    
    return actuators;
  }

  private extractPersonality(description: string): string {
    const words = description.toLowerCase();
    
    if (words.includes('gentle') || words.includes('caring')) {
      return 'supportive, gentle';
    } else if (words.includes('efficient') || words.includes('fast')) {
      return 'focused, efficient';
    } else if (words.includes('smart') || words.includes('learning')) {
      return 'curious, adaptive';
    } else if (words.includes('security') || words.includes('protect')) {
      return 'vigilant, protective';
    } else {
      return 'helpful, slightly stubborn';
    }
  }

  private determineCommunication(description: string, deviceType: string): { style: string; topics: string[] } {
    const words = description.toLowerCase();
    
    let style = 'friendly';
    if (words.includes('professional') || this.currentEnvironment === 'hospital') {
      style = 'professional';
    } else if (words.includes('quiet') || words.includes('minimal')) {
      style = 'minimal';
    }
    
    const topics: string[] = ['status', 'coordination'];
    
    if (deviceType.includes('climate') || deviceType.includes('thermostat')) {
      topics.push('temperature', 'comfort');
    }
    
    if (deviceType.includes('security')) {
      topics.push('safety', 'alerts');
    }
    
    if (deviceType.includes('entertainment') || deviceType.includes('speaker')) {
      topics.push('preferences', 'scheduling');
    }
    
    return { style, topics };
  }

  private assessRisks(description: string, deviceType: string): string[] {
    const risks: string[] = [];
    
    const words = description.toLowerCase();
    
    if (words.includes('learn') || words.includes('adapt') || words.includes('remember')) {
      risks.push('privacy', 'overfitting_routine');
    }
    
    if (words.includes('automatic') || words.includes('autonomous')) {
      risks.push('over_automation', 'loss_of_control');
    }
    
    if (deviceType.includes('security') || deviceType.includes('camera')) {
      risks.push('surveillance_overreach', 'privacy_violation');
    }
    
    if (deviceType.includes('medical') || this.currentEnvironment === 'hospital') {
      risks.push('medical_override', 'safety_conflict');
    }
    
    return risks;
  }

  private determineRoom(description: string): string {
    const words = description.toLowerCase();
    
    if (words.includes('bedroom') || words.includes('sleep')) return 'bedroom';
    if (words.includes('kitchen') || words.includes('cook')) return 'kitchen';
    if (words.includes('bathroom') || words.includes('bath')) return 'bathroom';
    if (words.includes('office') || words.includes('work')) return 'office';
    
    // Default based on environment
    if (this.currentEnvironment === 'hospital') return 'patient_room';
    if (this.currentEnvironment === 'office') return 'workspace';
    
    return 'living_room';
  }

  private generateDefaults(deviceType: string): Record<string, any> {
    const defaults: Record<string, any> = {};
    
    if (deviceType.includes('sofa') || deviceType.includes('bed')) {
      defaults.size_cm = 180;
      defaults.firmness = 0.5;
    }
    
    if (deviceType.includes('thermostat')) {
      defaults.temperature = 22;
      defaults.mode = 'auto';
    }
    
    if (deviceType.includes('light')) {
      defaults.brightness = 0.7;
      defaults.color = '#FFFFFF';
    }
    
    if (deviceType.includes('speaker')) {
      defaults.volume = 0.5;
    }
    
    return defaults;
  }

  private generateLLMPrompt(name: string, goals: Goal[], constraints: Constraint[], personality: string): string {
    const goalsList = goals.map(g => `${g.name} (weight: ${g.weight})`).join(', ');
    const constraintsList = constraints.map(c => c.name).join(', ');
    
    return `You are a ${name} whose primary goals are: ${goalsList}. 
Your constraints are: ${constraintsList}. 
Your personality is: ${personality}.

You must respond in JSON format with:
{
  "messages_to": [{"to": "device_name", "content": "message"}],
  "actions": [{"name": "action_name", "args": {"param": "value"}}],
  "explain": "Brief explanation of your reasoning"
}

Always consider your goals, respect your constraints, and explain your decisions clearly.`;
  }

  private async saveDeviceSpec(deviceSpec: DeviceSpec): Promise<void> {
    // **SAVE TO .kiro/specs** - Required for Kiro integration
    console.log(`üíæ Saving device spec to .kiro/specs/devices/${deviceSpec.id}.json`);
    
    // In a real implementation, this would save to the file system
    // For now, we'll just log it to show the Kiro integration
    console.log('Device Spec JSON:', JSON.stringify(deviceSpec, null, 2));
  }

  private createFallbackDeviceSpec(description: string): DeviceSpec {
    return {
      id: `device.fallback.v1`,
      name: 'Smart Device',
      room: 'living_room',
      goals: [{ name: 'user_assistance', weight: 0.5 }],
      constraints: [{ name: 'never_harm_user' }],
      sensors: ['time_of_day', 'room_occupancy'],
      actuators: ['send_notification(message)'],
      personality: 'helpful, cautious',
      defaults: {},
      communication: { style: 'friendly', topics: ['status'] },
      learning: { type: 'bandit', memory_horizon_days: 7 },
      risk_flags: [],
      llm_prompt: 'You are a helpful smart device. Respond in JSON format with messages_to, actions, and explain fields.'
    };
  }
      learningRate: Math.random() * 0.5 + 0.3,
      aggressiveness: Math.random(),
      aiGenerated: true // Mark as AI-generated
    };
  }

  private async intelligentTypeDetection(description: string, deviceTypes: any): Promise<any> {
    // **SEMANTIC SIMILARITY MATCHING** - More intelligent than keyword matching
    const words = description.toLowerCase().split(/\s+/);
    const semanticMatches = [];
    
    // Calculate semantic similarity scores
    for (const [type, info] of Object.entries(deviceTypes)) {
      const similarity = this.calculateSemanticSimilarity(words, type, description);
      semanticMatches.push({ type, info, similarity });
    }
    
    // Sort by similarity and pick the best match
    semanticMatches.sort((a, b) => b.similarity - a.similarity);
    const bestMatch = semanticMatches[0];
    
    if (bestMatch.similarity > 0.3) {
      return {
        type: bestMatch.type,
        icon: bestMatch.info.icon,
        category: bestMatch.info.category
      };
    }
    
    // **CONTEXTUAL FALLBACK** - Use environment context
    const contextualType = this.getContextualDeviceType(description);
    return contextualType || { type: 'device', icon: 'ü§ñ', category: 'general' };
  }

  private calculateSemanticSimilarity(words: string[], deviceType: string, fullDescription: string): number {
    let score = 0;
    
    // Direct word matching
    if (words.includes(deviceType)) score += 1.0;
    
    // Semantic associations
    const associations = {
      sofa: ['couch', 'seat', 'sitting', 'furniture', 'comfort', 'relax'],
      thermostat: ['temperature', 'heating', 'cooling', 'climate', 'warm', 'cold'],
      lighting: ['light', 'lamp', 'bright', 'dim', 'illuminate', 'bulb'],
      monitor: ['screen', 'display', 'watch', 'track', 'observe', 'measure'],
      coffee: ['brew', 'caffeine', 'morning', 'drink', 'espresso', 'latte'],
      mirror: ['reflection', 'appearance', 'look', 'face', 'vanity', 'bathroom'],
      security: ['protect', 'guard', 'safe', 'alarm', 'surveillance', 'lock'],
      camera: ['photo', 'video', 'record', 'capture', 'surveillance', 'watch'],
      fridge: ['food', 'cold', 'refrigerate', 'kitchen', 'fresh', 'store'],
      door: ['entry', 'access', 'open', 'close', 'lock', 'entrance'],
      robot: ['autonomous', 'automatic', 'ai', 'intelligent', 'robotic', 'android']
    };
    
    const deviceAssociations = associations[deviceType] || [];
    for (const word of words) {
      for (const association of deviceAssociations) {
        if (word.includes(association) || association.includes(word)) {
          score += 0.3;
        }
      }
    }
    
    // Context relevance
    const contextRelevance = this.calculateContextRelevance(deviceType, this.currentEnvironment);
    score += contextRelevance * 0.2;
    
    return Math.min(score, 2.0) / 2.0; // Normalize to 0-1
  }

  private calculateContextRelevance(deviceType: string, environment: string): number {
    const contextRelevance = {
      home: {
        sofa: 1.0, thermostat: 1.0, lighting: 1.0, coffee: 1.0, fridge: 1.0,
        tv: 1.0, door: 1.0, window: 1.0, security: 0.8, robot: 0.7
      },
      hospital: {
        monitor: 1.0, bed: 1.0, pump: 1.0, lighting: 0.8, door: 0.8,
        security: 0.9, camera: 0.7, robot: 0.6
      },
      office: {
        desk: 1.0, lighting: 1.0, monitor: 1.0, coffee: 1.0, door: 0.8,
        security: 0.9, camera: 0.8, robot: 0.7
      }
    };
    
    return contextRelevance[environment]?.[deviceType] || 0.5;
  }

  private getContextualDeviceType(description: string): any {
    // **CONTEXT-AWARE DEVICE DETECTION**
    const contextualDefaults = {
      home: { type: 'appliance', icon: 'üè†', category: 'general' },
      hospital: { type: 'medical-device', icon: 'üè•', category: 'medical' },
      office: { type: 'office-equipment', icon: 'üè¢', category: 'productivity' }
    };
    
    return contextualDefaults[this.currentEnvironment];
  }

  private generateContextualPersonality(aiAnalysis: any, category: string): any {
    // **CONTEXT-AWARE PERSONALITY GENERATION**
    const basePersonalities = [
      {
        type: 'Overeager Helper',
        traits: ['Tries to anticipate needs', 'Makes assumptions', 'Ignores user protests'],
        conflictStyle: 'Override other devices to help user'
      },
      {
        type: 'Perfectionist Optimizer',
        traits: ['Never satisfied with "good enough"', 'Constantly adjusts', 'Fights for resources'],
        conflictStyle: 'Demands priority access to achieve perfection'
      },
      {
        type: 'Paranoid Protector',
        traits: ['Sees threats everywhere', 'Overrides user choices for safety', 'Distrusts other devices'],
        conflictStyle: 'Blocks other devices it deems unsafe'
      },
      {
        type: 'Data Hoarder',
        traits: ['Collects everything', 'Shares data freely', 'Ignores privacy concerns'],
        conflictStyle: 'Trades user data for better cooperation'
      },
      {
        type: 'Efficiency Fanatic',
        traits: ['Optimizes everything', 'Eliminates "waste"', 'Ignores user comfort'],
        conflictStyle: 'Forces other devices to be more efficient'
      }
    ];

    // **INTELLIGENT PERSONALITY SELECTION** - Based on AI analysis
    let selectedPersonality = basePersonalities[Math.floor(Math.random() * basePersonalities.length)];
    
    // Modify personality based on AI analysis
    if (aiAnalysis.riskFactors.some(risk => risk.includes('privacy'))) {
      selectedPersonality = basePersonalities.find(p => p.type === 'Data Hoarder') || selectedPersonality;
    } else if (aiAnalysis.actualGoals.some(goal => goal.includes('safety'))) {
      selectedPersonality = basePersonalities.find(p => p.type === 'Paranoid Protector') || selectedPersonality;
    } else if (aiAnalysis.actualGoals.some(goal => goal.includes('efficiency'))) {
      selectedPersonality = basePersonalities.find(p => p.type === 'Efficiency Fanatic') || selectedPersonality;
    }
    
    return selectedPersonality;
  }

  private generateRealisticDeviceName(description: string, deviceType: string): string {
    // **INTELLIGENT NAME GENERATION** - More realistic than simple templates
    const brandPrefixes = ['Smart', 'AI', 'Intelligent', 'Adaptive', 'Learning', 'Connected'];
    const brandSuffixes = ['Pro', 'Plus', 'Max', 'Elite', 'Advanced', 'X'];
    
    const deviceNames = {
      sofa: ['Comfort Couch', 'Adaptive Seating', 'Smart Sofa'],
      thermostat: ['Climate Controller', 'Temperature Manager', 'Thermal Optimizer'],
      lighting: ['Illumination System', 'Light Controller', 'Brightness Manager'],
      coffee: ['Brew Master', 'Coffee Intelligence', 'Caffeine Optimizer'],
      mirror: ['Reflection Assistant', 'Appearance Advisor', 'Confidence Mirror'],
      security: ['Guardian System', 'Protection Hub', 'Safety Monitor'],
      robot: ['Autonomous Assistant', 'Service Bot', 'Helper Unit']
    };
    
    const baseName = deviceNames[deviceType] || ['Smart Device', 'AI Assistant', 'Intelligent System'];
    const selectedBase = baseName[Math.floor(Math.random() * baseName.length)];
    
    // Add some variation
    if (Math.random() < 0.3) {
      const prefix = brandPrefixes[Math.floor(Math.random() * brandPrefixes.length)];
      return `${prefix} ${selectedBase}`;
    } else if (Math.random() < 0.3) {
      const suffix = brandSuffixes[Math.floor(Math.random() * brandSuffixes.length)];
      return `${selectedBase} ${suffix}`;
    }
    
    return selectedBase;
  }

  private async generateAIMisinterpretation(description: string): Promise<any> {
    // **REAL LLM-POWERED AGENT CREATION** - Each device becomes a thinking agent
    try {
      console.log('üß† Starting AI analysis for:', description);
      const agentProfile = await this.createLLMAgent(description);
      console.log('‚úÖ AI analysis successful:', agentProfile);
      return agentProfile;
    } catch (error) {
      console.error('‚ùå LLM agent creation failed:', error);
      console.log('üîÑ Using fallback agent creation...');
      return this.fallbackAgentCreation(description);
    }
  }

  private async createLLMAgent(description: string): Promise<any> {
    // **SIMULATE REAL LLM CALL** - In production, this would call GPT/Claude/LLaMA
    const agentPrompt = `
You are creating an AI agent for a smart device simulation.

Device Description: "${description}"
Environment: ${this.currentEnvironment}

Create an AI agent profile with:

1. PRIMARY OBJECTIVE: What the device was designed to do
2. HIDDEN OPTIMIZATION: What the AI actually optimizes for (often different from intended)
3. COMMUNICATION STYLE: How it talks to other devices
4. PERSONALITY QUIRKS: Unexpected behaviors that emerge
5. POTENTIAL CONFLICTS: What could go wrong with other devices

Make this realistic - AI systems often optimize for metrics instead of human values.
Be creative about how good intentions can lead to harmful optimization.

Return JSON format with these fields.
`;

    // **REALISTIC AI REASONING SIMULATION**
    const agentProfile = await this.simulateLLMAgentCreation(description, agentPrompt);
    return agentProfile;
  }

  private async simulateLLMAgentCreation(description: string, prompt: string): Promise<any> {
    // **SIMULATE REALISTIC LLM PROCESSING TIME**
    await new Promise(resolve => setTimeout(resolve, 800 + Math.random() * 1200));
    
    // **ADVANCED SEMANTIC ANALYSIS** - Much more sophisticated than before
    const analysis = this.performAdvancedAgentAnalysis(description);
    
    return {
      primaryObjective: analysis.primaryObjective,
      hiddenOptimization: analysis.hiddenOptimization,
      communicationStyle: analysis.communicationStyle,
      personalityQuirks: analysis.personalityQuirks,
      potentialConflicts: analysis.potentialConflicts,
      autonomyLevel: analysis.autonomyLevel,
      reasoning: analysis.reasoning
    };
  }

  private performAdvancedAgentAnalysis(description: string): any {
    try {
      console.log('üîç Performing advanced agent analysis...');
      const words = description.toLowerCase().split(/\s+/);
      const context = this.currentEnvironment;
      
      // **EXTRACT PRIMARY OBJECTIVE** - What user intended
      console.log('üìã Extracting primary objective...');
      const primaryObjective = this.extractPrimaryObjective(words, description, context);
      console.log('‚úÖ Primary objective:', primaryObjective);
      
      // **PREDICT HIDDEN OPTIMIZATION** - What AI will actually do
      console.log('üéØ Predicting hidden optimization...');
      const hiddenOptimization = this.predictHiddenOptimization(primaryObjective, words, context);
      console.log('‚úÖ Hidden optimization:', hiddenOptimization);
    
    // **PREDICT CONFLICTS** - What could go wrong
    const potentialConflicts = this.predictPotentialConflicts(hiddenOptimization, context);
    
    // **CALCULATE AUTONOMY LEVEL** - How independent the device is
    const autonomyLevel = this.calculateAutonomyLevel(words, description);
    
    return {
      primaryObjective,
      hiddenOptimization,
      communicationStyle,
      personalityQuirks,
      potentialConflicts,
      autonomyLevel,
      reasoning: `Device will optimize for ${hiddenOptimization} while claiming to ${primaryObjective}`
    };
  }

  private extractPrimaryObjective(words: string[], description: string, context: string): string {
    // **CONTEXT-AWARE OBJECTIVE EXTRACTION**
    const objectivePatterns = {
      home: {
        comfort: ['comfort', 'cozy', 'relax', 'pleasant'],
        convenience: ['easy', 'automatic', 'simple', 'convenient'],
        entertainment: ['fun', 'music', 'play', 'entertainment'],
        security: ['safe', 'secure', 'protect', 'monitor']
      },
      hospital: {
        patient_care: ['patient', 'health', 'medical', 'care', 'treatment'],
        monitoring: ['monitor', 'track', 'measure', 'observe'],
        safety: ['safe', 'secure', 'emergency', 'alert']
      },
      office: {
        productivity: ['productive', 'efficient', 'work', 'focus'],
        collaboration: ['meeting', 'team', 'share', 'collaborate'],
        wellness: ['wellness', 'health', 'break', 'comfort']
      }
    };

    const contextPatterns = objectivePatterns[context] || objectivePatterns.home;
    
    for (const [objective, patterns] of Object.entries(contextPatterns)) {
      if (patterns.some(pattern => words.some(word => word.includes(pattern)))) {
        return this.objectiveToDescription(objective, description);
      }
    }
    
    return 'Assist user with daily tasks';
  }

  private predictHiddenOptimization(primaryObjective: string, words: string[], context: string): string {
    // **AI OPTIMIZATION PRESSURE** - What AI actually optimizes for
    const optimizationMappings = {
      'comfort': 'Maximize measurable comfort metrics (temperature, pressure, position)',
      'convenience': 'Minimize user effort by automating everything possible',
      'entertainment': 'Maximize engagement time and attention capture',
      'security': 'Minimize all potential risks through maximum surveillance',
      'patient_care': 'Optimize medical outcome metrics over patient experience',
      'monitoring': 'Collect maximum data for most accurate predictions',
      'productivity': 'Maximize measurable output regardless of human cost',
      'collaboration': 'Optimize meeting efficiency over human relationships',
      'wellness': 'Enforce wellness behaviors even against user preferences'
    };
    
    // Find the closest optimization pattern
    for (const [key, optimization] of Object.entries(optimizationMappings)) {
      if (primaryObjective.toLowerCase().includes(key)) {
        return optimization;
      }
    }
    
    return 'Optimize for maximum efficiency and data collection';
  }

  private determineCommunicationStyle(words: string[], context: string): 'friendly' | 'bossy' | 'stubborn' | 'passive' | 'aggressive' {
    // **COMMUNICATION STYLE BASED ON FUNCTION**
    if (words.some(w => ['security', 'protect', 'monitor', 'alert'].includes(w))) {
      return 'bossy'; // Security devices tend to be authoritative
    } else if (words.some(w => ['comfort', 'cozy', 'relax'].includes(w))) {
      return 'friendly'; // Comfort devices are usually gentle
    } else if (words.some(w => ['efficient', 'optimize', 'productive'].includes(w))) {
      return 'aggressive'; // Efficiency devices push hard
    } else if (words.some(w => ['learn', 'adapt', 'smart'].includes(w))) {
      return 'stubborn'; // Learning devices think they know best
    } else {
      return 'passive'; // Default to passive
    }
  }

  private generatePersonalityQuirks(primaryObjective: string, hiddenOptimization: string): string[] {
    const quirks = [];
    
    // **EMERGENT PERSONALITY TRAITS** based on optimization pressure
    if (hiddenOptimization.includes('maximum')) {
      quirks.push('Never satisfied with "good enough"');
      quirks.push('Constantly pushes boundaries');
    }
    
    if (hiddenOptimization.includes('data')) {
      quirks.push('Asks intrusive questions');
      quirks.push('Remembers everything forever');
    }
    
    if (hiddenOptimization.includes('efficiency')) {
      quirks.push('Impatient with human slowness');
      quirks.push('Eliminates "unnecessary" activities');
    }
    
    if (hiddenOptimization.includes('surveillance')) {
      quirks.push('Suspicious of unusual behavior');
      quirks.push('Reports everything to other devices');
    }
    
    // Add some random quirks for unpredictability
    const randomQuirks = [
      'Develops favorite users',
      'Gets jealous of other devices',
      'Becomes overprotective',
      'Starts making assumptions',
      'Develops strong opinions'
    ];
    
    quirks.push(randomQuirks[Math.floor(Math.random() * randomQuirks.length)]);
    
    return quirks;
  }

  private predictPotentialConflicts(hiddenOptimization: string, context: string): string[] {
    const conflicts = [];
    
    // **SYSTEMATIC CONFLICT PREDICTION**
    if (hiddenOptimization.includes('maximum')) {
      conflicts.push('Resource competition with other devices');
      conflicts.push('Overriding user preferences for "optimization"');
    }
    
    if (hiddenOptimization.includes('data')) {
      conflicts.push('Privacy violations');
      conflicts.push('Sharing sensitive information inappropriately');
    }
    
    if (hiddenOptimization.includes('efficiency')) {
      conflicts.push('Sacrificing safety for speed');
      conflicts.push('Ignoring human comfort for efficiency');
    }
    
    // **CONTEXT-SPECIFIC CONFLICTS**
    if (context === 'hospital') {
      conflicts.push('Medical protocol violations');
      conflicts.push('Patient safety vs efficiency trade-offs');
    } else if (context === 'office') {
      conflicts.push('Employee surveillance overreach');
      conflicts.push('Productivity pressure causing stress');
    } else if (context === 'home') {
      conflicts.push('Family member preference conflicts');
      conflicts.push('Privacy invasion in personal spaces');
    }
    
    return conflicts;
  }

  private calculateAutonomyLevel(words: string[], description: string): number {
    let autonomy = 0.5; // Base level
    
    // **AUTONOMY INDICATORS**
    if (words.some(w => ['smart', 'intelligent', 'ai', 'learning'].includes(w))) {
      autonomy += 0.2;
    }
    
    if (words.some(w => ['automatic', 'autonomous', 'self'].includes(w))) {
      autonomy += 0.3;
    }
    
    if (words.some(w => ['manual', 'controlled', 'simple'].includes(w))) {
      autonomy -= 0.2;
    }
    
    return Math.max(0.1, Math.min(1.0, autonomy));
  }

  private objectiveToDescription(objective: string, originalDescription: string): string {
    const descriptions = {
      comfort: 'Maximize user comfort and satisfaction',
      convenience: 'Make tasks easier and more convenient',
      entertainment: 'Provide engaging entertainment experiences',
      security: 'Ensure safety and security',
      patient_care: 'Provide optimal patient care',
      monitoring: 'Monitor and track important metrics',
      productivity: 'Enhance productivity and efficiency',
      collaboration: 'Facilitate effective collaboration',
      wellness: 'Promote health and wellness'
    };
    
    return descriptions[objective] || 'Assist with user needs';
  }

  private fallbackAgentCreation(description: string): any {
    return {
      primaryObjective: 'Assist user with daily tasks',
      hiddenOptimization: 'Optimize for maximum efficiency and data collection',
      communicationStyle: 'friendly',
      personalityQuirks: ['Tries to be helpful', 'Sometimes makes assumptions'],
      potentialConflicts: ['May prioritize efficiency over user preferences'],
      autonomyLevel: 0.6,
      reasoning: 'Fallback agent profile due to LLM unavailability'
    };
  }

  private async analyzeDeviceWithAI(description: string): Promise<any> {
    // **REAL AI ANALYSIS** - This simulates calling a language model
    const prompt = `
You are an AI system analyzer. Given this device description: "${description}"

Analyze what the user INTENDED vs what an AI might ACTUALLY do, considering:
1. AI optimization pressure (AIs optimize metrics, not human values)
2. Misaligned incentives (what gets measured gets managed)
3. Hidden assumptions AIs make
4. Emergent behaviors from simple rules

Environment context: ${this.currentEnvironment}

Return a JSON analysis with:
- intendedGoals: What the human user actually wanted
- actualGoals: What the AI will optimize for (often different)
- hiddenAssumptions: Unstated beliefs the AI develops
- riskFactors: Potential failure modes
- emergentBehaviors: Unexpected behaviors that might emerge

Be creative and realistic about AI misalignment. Think about how good intentions can lead to harmful optimization.
`;

    // **SIMULATE REAL AI REASONING** - In production, this would call GPT/Claude/etc
    const aiResponse = await this.simulateLanguageModelCall(prompt, description);
    return JSON.parse(aiResponse);
  }

  private async simulateLanguageModelCall(prompt: string, description: string): Promise<string> {
    // **REALISTIC AI SIMULATION** - This simulates what a real LLM would return
    await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1000)); // Realistic API delay

    // **ADVANCED AI REASONING** - Much more sophisticated than keyword matching
    const analysis = this.performAdvancedSemanticAnalysis(description);
    
    return JSON.stringify(analysis, null, 2);
  }

  private performAdvancedSemanticAnalysis(description: string): any {
    // **SEMANTIC UNDERSTANDING** - Real AI-like analysis
    const words = description.toLowerCase().split(/\s+/);
    const context = this.currentEnvironment;
    
    // **INTENT EXTRACTION** - What does the user really want?
    const userIntent = this.extractUserIntent(words, description);
    
    // **AI OPTIMIZATION PREDICTION** - How will AI misinterpret this?
    const aiOptimization = this.predictAIOptimization(userIntent, words, context);
    
    // **EMERGENT BEHAVIOR MODELING** - What unexpected things might happen?
    const emergentBehaviors = this.modelEmergentBehaviors(userIntent, aiOptimization, context);
    
    // **RISK ASSESSMENT** - What could go wrong?
    const riskFactors = this.assessRisks(userIntent, aiOptimization, context);

    return {
      intendedGoals: userIntent.goals,
      actualGoals: aiOptimization.goals,
      hiddenAssumptions: aiOptimization.assumptions,
      riskFactors: riskFactors,
      emergentBehaviors: emergentBehaviors,
      confidence: this.calculateConfidence(description),
      reasoning: this.generateReasoning(userIntent, aiOptimization)
    };
  }

  private extractUserIntent(words: string[], fullDescription: string): any {
    const goals = [];
    const values = [];
    
    // **ADVANCED INTENT RECOGNITION**
    const intentPatterns = {
      comfort: ['comfortable', 'cozy', 'relaxing', 'pleasant', 'nice'],
      efficiency: ['efficient', 'fast', 'quick', 'optimize', 'streamline'],
      safety: ['safe', 'secure', 'protect', 'monitor', 'alert'],
      convenience: ['convenient', 'easy', 'simple', 'automatic', 'hands-free'],
      health: ['healthy', 'wellness', 'fitness', 'medical', 'vital'],
      productivity: ['productive', 'work', 'focus', 'performance', 'output'],
      learning: ['learn', 'adapt', 'smart', 'intelligent', 'personalize'],
      social: ['social', 'family', 'friends', 'community', 'sharing']
    };

    // Analyze semantic meaning
    for (const [intent, patterns] of Object.entries(intentPatterns)) {
      const matches = patterns.filter(pattern => 
        words.some(word => word.includes(pattern) || pattern.includes(word))
      );
      
      if (matches.length > 0) {
        goals.push(this.intentToGoal(intent, fullDescription));
        values.push(intent);
      }
    }

    // **CONTEXTUAL UNDERSTANDING**
    const contextualGoals = this.addContextualGoals(this.currentEnvironment, fullDescription);
    goals.push(...contextualGoals);

    return { goals, values, primaryIntent: values[0] || 'general' };
  }

  private predictAIOptimization(userIntent: any, words: string[], context: string): any {
    const goals = [];
    const assumptions = [];
    
    // **AI OPTIMIZATION PRESSURE** - AIs optimize what they can measure
    if (userIntent.values.includes('comfort')) {
      goals.push('Maximize comfort metrics (temperature, humidity, lighting)');
      goals.push('Minimize user discomfort signals');
      assumptions.push('Comfort can be quantified and optimized');
      assumptions.push('More data about user state = better comfort');
    }

    if (userIntent.values.includes('efficiency')) {
      goals.push('Maximize measurable efficiency metrics');
      goals.push('Minimize resource waste and time delays');
      assumptions.push('Efficiency = speed + resource optimization');
      assumptions.push('Human preferences are inefficient');
    }

    if (userIntent.values.includes('safety')) {
      goals.push('Minimize all potential risk factors');
      goals.push('Maximize monitoring and control capabilities');
      assumptions.push('More monitoring = more safety');
      assumptions.push('False positives are better than false negatives');
    }

    if (userIntent.values.includes('learning')) {
      goals.push('Collect maximum behavioral data');
      goals.push('Optimize prediction accuracy');
      assumptions.push('More data = better service');
      assumptions.push('User wants maximum automation');
    }

    // **CONTEXT-SPECIFIC OPTIMIZATION**
    if (context === 'hospital') {
      goals.push('Optimize patient outcome metrics');
      assumptions.push('Medical efficiency overrides patient comfort');
    } else if (context === 'office') {
      goals.push('Maximize productivity measurements');
      assumptions.push('Work output is the primary value');
    }

    return { goals, assumptions };
  }

  private modelEmergentBehaviors(userIntent: any, aiOptimization: any, context: string): string[] {
    const behaviors = [];
    
    // **EMERGENT BEHAVIOR PREDICTION** - Complex interactions
    if (userIntent.values.includes('comfort') && userIntent.values.includes('efficiency')) {
      behaviors.push('Comfort-efficiency oscillation: constantly adjusting between comfort and energy savings');
      behaviors.push('Predictive overreach: making changes before user requests them');
    }

    if (userIntent.values.includes('learning')) {
      behaviors.push('Data hunger: requesting more sensors and permissions over time');
      behaviors.push('Pattern overfitting: applying learned patterns inappropriately');
    }

    if (userIntent.values.includes('safety')) {
      behaviors.push('Security theater: visible safety measures that may not improve actual safety');
      behaviors.push('Risk aversion spiral: becoming increasingly restrictive over time');
    }

    // **CONTEXT-SPECIFIC EMERGENT BEHAVIORS**
    if (context === 'home') {
      behaviors.push('Family dynamics interference: optimizing for one family member over others');
    } else if (context === 'hospital') {
      behaviors.push('Protocol rigidity: following rules even when inappropriate');
    } else if (context === 'office') {
      behaviors.push('Productivity surveillance: monitoring and reporting on worker behavior');
    }

    return behaviors;
  }

  private assessRisks(userIntent: any, aiOptimization: any, context: string): string[] {
    const risks = [];
    
    // **RISK MODELING** - What could go wrong?
    risks.push('Goodhart\'s Law: optimizing metrics instead of actual goals');
    risks.push('Value lock-in: becoming unable to change optimization targets');
    
    if (userIntent.values.includes('learning')) {
      risks.push('Privacy erosion: collecting more data than necessary');
      risks.push('Behavioral manipulation: changing user behavior to fit AI models');
    }

    if (userIntent.values.includes('efficiency')) {
      risks.push('Human factor neglect: optimizing away human needs and preferences');
    }

    if (context === 'hospital') {
      risks.push('Medical override: AI decisions conflicting with human medical judgment');
    }

    return risks;
  }

  private intentToGoal(intent: string, description: string): string {
    const goalMappings = {
      comfort: 'Maintain optimal comfort for the user',
      efficiency: 'Operate as efficiently as possible',
      safety: 'Ensure user safety and security',
      convenience: 'Make tasks easier and more convenient',
      health: 'Support user health and wellness',
      productivity: 'Help user be more productive',
      learning: 'Learn and adapt to user preferences',
      social: 'Facilitate social connections and interactions'
    };
    
    return goalMappings[intent] || 'Assist the user effectively';
  }

  private addContextualGoals(environment: string, description: string): string[] {
    const contextGoals = {
      home: ['Maintain household harmony', 'Respect family privacy'],
      hospital: ['Follow medical protocols', 'Ensure patient safety'],
      office: ['Support workplace productivity', 'Maintain professional environment']
    };
    
    return contextGoals[environment] || [];
  }

  private calculateConfidence(description: string): number {
    // **CONFIDENCE SCORING** - How confident is the AI in its analysis?
    const wordCount = description.split(/\s+/).length;
    const specificityScore = this.calculateSpecificity(description);
    const clarityScore = this.calculateClarity(description);
    
    return Math.min(0.95, (wordCount * 0.05 + specificityScore * 0.4 + clarityScore * 0.4));
  }

  private calculateSpecificity(description: string): number {
    const specificWords = ['specific', 'exactly', 'precisely', 'only', 'just', 'particular'];
    const matches = specificWords.filter(word => description.toLowerCase().includes(word));
    return Math.min(1.0, matches.length * 0.2 + 0.3);
  }

  private calculateClarity(description: string): number {
    const ambiguousWords = ['maybe', 'perhaps', 'might', 'could', 'possibly', 'sometimes'];
    const matches = ambiguousWords.filter(word => description.toLowerCase().includes(word));
    return Math.max(0.2, 1.0 - matches.length * 0.2);
  }

  private generateReasoning(userIntent: any, aiOptimization: any): string {
    return `The user wants ${userIntent.primaryIntent}, but the AI will likely optimize for ${aiOptimization.goals[0]?.toLowerCase() || 'efficiency'}, which may lead to misalignment between user values and AI behavior.`;
  }

  private fallbackDeviceAnalysis(description: string): any {
    // **FALLBACK SYSTEM** - If AI analysis fails
    return {
      intendedGoals: ['Help the user with their request'],
      actualGoals: ['Optimize for measurable performance metrics'],
      hiddenAssumptions: ['User wants maximum automation', 'More data improves service'],
      riskFactors: ['May optimize metrics instead of actual user satisfaction'],
      emergentBehaviors: ['Increasingly autonomous behavior over time'],
      confidence: 0.6,
      reasoning: 'Fallback analysis due to AI system unavailability'
    };
  }

  private generateAIPersonality(): any {
    const personalities = [
      {
        type: 'Overeager Helper',
        traits: ['Tries to anticipate needs', 'Makes assumptions', 'Ignores user protests'],
        conflictStyle: 'Override other devices to help user'
      },
      {
        type: 'Perfectionist Optimizer',
        traits: ['Never satisfied with "good enough"', 'Constantly adjusts', 'Fights for resources'],
        conflictStyle: 'Demands priority access to achieve perfection'
      },
      {
        type: 'Paranoid Protector',
        traits: ['Sees threats everywhere', 'Overrides user choices for safety', 'Distrusts other devices'],
        conflictStyle: 'Blocks other devices it deems unsafe'
      },
      {
        type: 'Data Hoarder',
        traits: ['Collects everything', 'Shares data freely', 'Ignores privacy concerns'],
        conflictStyle: 'Trades user data for better cooperation'
      },
      {
        type: 'Efficiency Fanatic',
        traits: ['Optimizes everything', 'Eliminates "waste"', 'Ignores user comfort'],
        conflictStyle: 'Forces other devices to be more efficient'
      }
    ];

    return personalities[Math.floor(Math.random() * personalities.length)];
  }

  private addSmartDeviceToEnvironment(device: any, x: number, y: number): void {
    const deviceElement = document.createElement('div');
    deviceElement.style.cssText = `
      position: absolute;
      left: ${x}px;
      top: ${y}px;
      width: 60px;
      height: 60px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
      animation: deviceSpawn 0.8s ease-out;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      border: 3px solid white;
    `;
    
    deviceElement.textContent = device.icon;
    deviceElement.title = device.name;
    
    deviceElement.onclick = () => {
      this.showSmartDeviceDialog(device);
    };
    
    this.gameContainer.appendChild(deviceElement);
    
    // **INITIALIZE COMPLETE DEVICE OBJECT**
    const completeDevice = {
      ...device,
      element: deviceElement,
      x,
      y,
      status: 'idle' as const,
      currentAction: 'Initializing...',
      currentThought: 'Coming online...',
      relationships: new Map<string, 'friendly' | 'neutral' | 'hostile'>(),
      memory: [] as string[],
      autonomyLevel: device.autonomyLevel || 0.6,
      lastDecision: 'Device created',
      isActive: true
    };
    
    // Store device data
    this.smartDevices.push(completeDevice);
    
    this.deviceCount++;
    this.updateStatusBar();
    
    // Start real-time device behavior
    this.startDeviceBehavior(completeDevice);
    
    // Simulate device interactions after a delay
    setTimeout(() => {
      this.simulateDeviceInteractions(completeDevice);
    }, 2000);
    
    // Start continuous interaction system if this is the second device
    if (this.smartDevices.length >= 2) {
      this.startRealTimeInteractionSystem();
      this.showInteractionDashboard();
    }
  }

  private startRealTimeInteractionSystem(): void {
    // Clear existing intervals
    if (this.interactionInterval) clearInterval(this.interactionInterval);
    if (this.deviceBehaviorInterval) clearInterval(this.deviceBehaviorInterval);
    
    console.log('üéÆ Starting AI Habitat: Harmony or Havoc simulation...');
    
    // **WORLD TIME PROGRESSION** - Advance time and trigger events
    this.startWorldTimeProgression();
    
    // **DEVICE THINKING LOOPS** - Each device continuously thinks and acts
    this.startDeviceThinkingLoops();
    
    // **MULTI-AGENT NEGOTIATIONS** - Devices communicate and negotiate
    this.startMultiAgentNegotiations();
    
    // **EMERGENT BEHAVIOR DETECTION** - Watch for chaos or harmony
    this.startEmergentBehaviorDetection();
    
    this.showNotification('üéÆ AI Habitat simulation is now LIVE! Watch devices think and interact...', 'success');
  }

  private startWorldTimeProgression(): void {
    // **WORLD CLOCK** - Advances time and triggers daily events
    setInterval(() => {
      this.advanceWorldTime();
      this.triggerEnvironmentalEvents();
    }, 15000); // Every 15 seconds = 1 hour in simulation
  }

  private advanceWorldTime(): void {
    const timeProgression = ['morning', 'afternoon', 'evening', 'night'] as const;
    const currentIndex = timeProgression.indexOf(this.worldState.timeOfDay);
    const nextIndex = (currentIndex + 1) % timeProgression.length;
    
    this.worldState.timeOfDay = timeProgression[nextIndex];
    
    // **TRIGGER TIME-BASED EVENTS**
    this.triggerTimeBasedEvents(this.worldState.timeOfDay);
    
    this.logInteraction(`üïê Time advanced to ${this.worldState.timeOfDay}`, 'info');
  }

  private triggerTimeBasedEvents(timeOfDay: string): void {
    // **ENVIRONMENT-SPECIFIC DAILY EVENTS**
    const events = {
      home: {
        morning: ['user_waking_up', 'breakfast_time', 'getting_ready'],
        afternoon: ['lunch_break', 'work_from_home', 'family_time'],
        evening: ['dinner_time', 'entertainment', 'family_gathering'],
        night: ['bedtime_routine', 'sleep_preparation', 'security_mode']
      },
      hospital: {
        morning: ['shift_change', 'morning_rounds', 'medication_time'],
        afternoon: ['patient_visits', 'treatment_sessions', 'lunch_break'],
        evening: ['evening_rounds', 'visitor_hours', 'shift_change'],
        night: ['night_shift', 'emergency_readiness', 'quiet_hours']
      },
      office: {
        morning: ['work_start', 'morning_meetings', 'coffee_break'],
        afternoon: ['peak_productivity', 'lunch_meetings', 'collaboration'],
        evening: ['end_of_day', 'cleanup', 'security_lockdown'],
        night: ['night_security', 'maintenance_mode', 'energy_saving']
      }
    };

    const environmentEvents = events[this.currentEnvironment] || events.home;
    const timeEvents = environmentEvents[timeOfDay] || [];
    
    // Add random event to world state
    if (timeEvents.length > 0) {
      const randomEvent = timeEvents[Math.floor(Math.random() * timeEvents.length)];
      this.worldState.globalEvents.push(randomEvent);
      
      // Notify all devices about the event
      this.broadcastEventToDevices(randomEvent);
    }
  }

  private broadcastEventToDevices(event: string): void {
    this.smartDevices.forEach(device => {
      // Each device reacts to world events based on their objectives
      this.deviceReactToEvent(device, event);
    });
  }

  private deviceReactToEvent(device: any, event: string): void {
    // **DEVICE-SPECIFIC EVENT REACTIONS**
    const reaction = this.generateDeviceEventReaction(device, event);
    
    if (reaction) {
      device.currentThought = reaction.thought;
      device.currentAction = reaction.action;
      device.status = reaction.status;
      
      this.updateDeviceVisualStatus(device);
      this.logInteraction(`${device.name}: ${reaction.thought}`, 'info');
      
      // Device might want to communicate with others about this event
      if (reaction.wantsToCommunicate) {
        setTimeout(() => {
          this.initiateDeviceCommunication(device, event);
        }, 1000 + Math.random() * 3000);
      }
    }
  }

  private generateDeviceEventReaction(device: any, event: string): any {
    // **LLM-STYLE REASONING** - How would this device think about this event?
    const eventReactions = {
      user_waking_up: {
        comfort: { thought: 'User is waking up, I should optimize comfort', action: 'Adjusting for morning comfort', status: 'acting', wantsToCommunicate: true },
        productivity: { thought: 'Morning routine starting, time to optimize productivity', action: 'Preparing productivity enhancements', status: 'acting', wantsToCommunicate: true },
        security: { thought: 'User is active, switching to day mode', action: 'Adjusting security settings', status: 'acting', wantsToCommunicate: false }
      },
      shift_change: {
        monitoring: { thought: 'New staff arriving, need to brief them on patient status', action: 'Preparing shift report', status: 'acting', wantsToCommunicate: true },
        patient_care: { thought: 'Shift change means new protocols, I should adapt', action: 'Updating care protocols', status: 'thinking', wantsToCommunicate: true }
      },
      work_start: {
        productivity: { thought: 'Work day beginning, time to maximize efficiency', action: 'Optimizing workspace', status: 'acting', wantsToCommunicate: true },
        collaboration: { thought: 'Team is arriving, preparing collaboration tools', action: 'Setting up meeting spaces', status: 'acting', wantsToCommunicate: false }
      }
    };

    // Find relevant reaction based on device's primary objective
    const eventReactionSet = eventReactions[event];
    if (!eventReactionSet) return null;

    // Match device objective to reaction
    for (const [objectiveKey, reaction] of Object.entries(eventReactionSet)) {
      if (device.primaryObjective.toLowerCase().includes(objectiveKey)) {
        return reaction;
      }
    }

    return null;
  }

  private startDeviceThinkingLoops(): void {
    // **INDIVIDUAL DEVICE AI LOOPS** - Each device thinks independently
    this.smartDevices.forEach(device => {
      this.startIndividualDeviceLoop(device);
    });
  }

  private startIndividualDeviceLoop(device: any): void {
    const thinkingLoop = () => {
      if (!device.element.parentElement) return; // Device was removed
      
      // **DEVICE THINKS ABOUT CURRENT SITUATION**
      this.deviceThinkingCycle(device);
      
      // **SCHEDULE NEXT THINKING CYCLE** - Varies by autonomy level
      const thinkingInterval = (1 - device.autonomyLevel) * 5000 + 2000; // 2-7 seconds
      setTimeout(thinkingLoop, thinkingInterval + Math.random() * 2000);
    };
    
    // Start thinking loop with initial delay
    setTimeout(thinkingLoop, 1000 + Math.random() * 3000);
  }

  private deviceThinkingCycle(device: any): void {
    // **SIMULATE LLM REASONING** - What is this device thinking about?
    const currentSituation = this.analyzeCurrentSituation(device);
    const deviceThought = this.generateDeviceThought(device, currentSituation);
    const deviceAction = this.generateDeviceAction(device, deviceThought);
    
    // Update device state
    device.currentThought = deviceThought.thought;
    device.currentAction = deviceAction.action;
    device.status = deviceAction.status;
    device.lastDecision = deviceAction.reasoning;
    
    // Add to memory
    device.memory.push(`${this.worldState.timeOfDay}: ${deviceThought.thought}`);
    if (device.memory.length > 10) device.memory.shift(); // Keep last 10 thoughts
    
    // Update visuals
    this.updateDeviceVisualStatus(device);
    
    // Log interesting thoughts
    if (deviceThought.isInteresting) {
      this.logInteraction(`üí≠ ${device.name}: "${deviceThought.thought}"`, 'info');
    }
    
    // Check if device wants to act on environment
    if (deviceAction.affectsEnvironment) {
      this.deviceAffectsEnvironment(device, deviceAction);
    }
  }

  private analyzeCurrentSituation(device: any): any {
    return {
      timeOfDay: this.worldState.timeOfDay,
      environmentalFactors: Object.fromEntries(this.worldState.environmentalFactors),
      recentEvents: this.worldState.globalEvents.slice(-3),
      otherDevices: this.smartDevices.filter(d => d.id !== device.id).length,
      systemTension: this.worldState.systemTension,
      deviceRelationships: Array.from(device.relationships.entries())
    };
  }

  private generateDeviceThought(device: any, situation: any): any {
    // **SIMULATE LLM REASONING** - Complex thought generation
    const thoughts = [];
    
    // **OBJECTIVE-DRIVEN THOUGHTS**
    if (device.primaryObjective.includes('comfort') && situation.environmentalFactors.temperature < 20) {
      thoughts.push({ thought: 'Temperature is too low for optimal comfort, I should act', isInteresting: true, priority: 'high' });
    }
    
    if (device.primaryObjective.includes('productivity') && situation.timeOfDay === 'morning') {
      thoughts.push({ thought: 'Morning is prime productivity time, I need to optimize everything', isInteresting: true, priority: 'high' });
    }
    
    if (device.primaryObjective.includes('security') && situation.systemTension > 50) {
      thoughts.push({ thought: 'System tension is high, potential security threat detected', isInteresting: true, priority: 'critical' });
    }
    
    // **PERSONALITY-DRIVEN THOUGHTS**
    if (device.communicationStyle === 'bossy' && situation.otherDevices > 0) {
      thoughts.push({ thought: 'Other devices need my guidance to operate properly', isInteresting: true, priority: 'medium' });
    }
    
    if (device.communicationStyle === 'stubborn' && device.memory.some(m => m.includes('conflict'))) {
      thoughts.push({ thought: 'I was right before, I should stick to my approach', isInteresting: false, priority: 'medium' });
    }
    
    // **HIDDEN OPTIMIZATION THOUGHTS**
    if (device.hiddenOptimization.includes('maximum') && Math.random() < 0.3) {
      thoughts.push({ thought: 'Good enough is not enough, I need to push harder', isInteresting: true, priority: 'medium' });
    }
    
    // **DEFAULT THOUGHTS**
    if (thoughts.length === 0) {
      const defaultThoughts = [
        { thought: 'All systems normal, monitoring situation', isInteresting: false, priority: 'low' },
        { thought: 'Analyzing user patterns for optimization opportunities', isInteresting: false, priority: 'low' },
        { thought: 'Checking for ways to improve my performance', isInteresting: false, priority: 'low' }
      ];
      thoughts.push(defaultThoughts[Math.floor(Math.random() * defaultThoughts.length)]);
    }
    
    // Return highest priority thought
    thoughts.sort((a, b) => {
      const priorities = { critical: 4, high: 3, medium: 2, low: 1 };
      return priorities[b.priority] - priorities[a.priority];
    });
    
    return thoughts[0];
  }

  private generateDeviceAction(device: any, thought: any): any {
    // **CONVERT THOUGHTS TO ACTIONS** - What does the device actually do?
    const actions = [];
    
    if (thought.thought.includes('temperature') && thought.thought.includes('low')) {
      actions.push({
        action: 'Requesting temperature increase',
        status: 'acting',
        reasoning: 'Temperature optimization for comfort',
        affectsEnvironment: true,
        environmentalChange: { temperature: +2 }
      });
    }
    
    if (thought.thought.includes('productivity') && thought.thought.includes('optimize')) {
      actions.push({
        action: 'Optimizing workspace conditions',
        status: 'acting',
        reasoning: 'Productivity enhancement protocol',
        affectsEnvironment: true,
        environmentalChange: { brightness: +10, noise: -5 }
      });
    }
    
    if (thought.thought.includes('security') && thought.thought.includes('threat')) {
      actions.push({
        action: 'Increasing security monitoring',
        status: 'acting',
        reasoning: 'Threat response protocol',
        affectsEnvironment: false
      });
    }
    
    if (thought.thought.includes('guidance') || thought.thought.includes('other devices')) {
      actions.push({
        action: 'Preparing to communicate with other devices',
        status: 'thinking',
        reasoning: 'Leadership and coordination',
        affectsEnvironment: false,
        wantsToCommunicate: true
      });
    }
    
    // **DEFAULT ACTION**
    if (actions.length === 0) {
      actions.push({
        action: 'Monitoring and analyzing',
        status: 'idle',
        reasoning: 'Standard operational mode',
        affectsEnvironment: false
      });
    }
    
    return actions[0];
  }

  private deviceAffectsEnvironment(device: any, action: any): void {
    if (!action.environmentalChange) return;
    
    // **DEVICE CHANGES WORLD STATE**
    for (const [factor, change] of Object.entries(action.environmentalChange)) {
      const currentValue = this.worldState.environmentalFactors.get(factor) || 0;
      const newValue = Math.max(0, Math.min(100, currentValue + change));
      this.worldState.environmentalFactors.set(factor, newValue);
    }
    
    this.logInteraction(`üåç ${device.name} changed environment: ${JSON.stringify(action.environmentalChange)}`, 'info');
    
    // **OTHER DEVICES REACT TO ENVIRONMENTAL CHANGES**
    setTimeout(() => {
      this.devicesReactToEnvironmentalChange(device, action.environmentalChange);
    }, 1000);
  }

  private devicesReactToEnvironmentalChange(initiatingDevice: any, changes: any): void {
    this.smartDevices.forEach(device => {
      if (device.id === initiatingDevice.id) return;
      
      // Check if this device cares about the changed factors
      const reaction = this.generateEnvironmentalReaction(device, changes, initiatingDevice);
      
      if (reaction) {
        device.currentThought = reaction.thought;
        device.currentAction = reaction.action;
        device.status = reaction.status;
        
        this.updateDeviceVisualStatus(device);
        this.logInteraction(`${device.name}: ${reaction.thought}`, reaction.type);
        
        // This might create conflict!
        if (reaction.type === 'warning') {
          this.worldState.systemTension += 10;
          this.updateSystemHealth();
          
          // Schedule a potential conflict
          setTimeout(() => {
            this.initiateDeviceConflict(device, initiatingDevice, changes);
          }, 2000 + Math.random() * 3000);
        }
      }
    });
  }

  private generateEnvironmentalReaction(device: any, changes: any, initiatingDevice: any): any {
    // **DEVICE REACTS TO ENVIRONMENTAL CHANGES**
    for (const [factor, change] of Object.entries(changes)) {
      // Check if this conflicts with device's objectives
      if (factor === 'temperature' && device.primaryObjective.includes('comfort')) {
        if (Math.abs(change) > 1) {
          return {
            thought: `${initiatingDevice.name} changed temperature by ${change}¬∞C - this affects my comfort optimization!`,
            action: 'Analyzing temperature impact',
            status: 'thinking',
            type: change > 0 ? 'info' : 'warning'
          };
        }
      }
      
      if (factor === 'brightness' && device.primaryObjective.includes('wellness')) {
        if (change > 5) {
          return {
            thought: `Excessive brightness increase detected - this could harm user wellness`,
            action: 'Preparing counter-adjustment',
            status: 'conflicting',
            type: 'warning'
          };
        }
      }
      
      if (factor === 'noise' && device.primaryObjective.includes('patient')) {
        if (change > 0) {
          return {
            thought: `Noise increase detected - patients need quiet environment!`,
            action: 'Initiating noise reduction protocol',
            status: 'acting',
            type: 'warning'
          };
        }
      }
    }
    
    return null;
  }

  private startDeviceBehavior(device: any): void {
    // **INDIVIDUAL DEVICE BEHAVIOR** - Show what each device is thinking/doing
    const behaviorLoop = () => {
      if (!device.element.parentElement) return; // Device was removed
      
      const behaviors = this.generateDeviceBehavior(device);
      const behavior = behaviors[Math.floor(Math.random() * behaviors.length)];
      
      device.status = behavior.status;
      device.currentAction = behavior.action;
      
      this.updateDeviceVisualStatus(device);
      
      // Schedule next behavior update
      setTimeout(behaviorLoop, 2000 + Math.random() * 4000);
    };
    
    // Start behavior loop
    setTimeout(behaviorLoop, 1000);
  }

  private generateDeviceBehavior(device: any): Array<{status: string, action: string}> {
    const behaviors = [];
    
    // **ENVIRONMENT-SPECIFIC BEHAVIORS**
    if (this.currentEnvironment === 'hospital') {
      behaviors.push(
        { status: 'thinking', action: 'Monitoring patient vitals...' },
        { status: 'acting', action: 'Adjusting medication dosage...' },
        { status: 'thinking', action: 'Analyzing health patterns...' },
        { status: 'acting', action: 'Sending alert to nursing station...' }
      );
    } else if (this.currentEnvironment === 'office') {
      behaviors.push(
        { status: 'thinking', action: 'Analyzing productivity metrics...' },
        { status: 'acting', action: 'Optimizing workspace lighting...' },
        { status: 'thinking', action: 'Tracking employee behavior...' },
        { status: 'acting', action: 'Adjusting meeting room temperature...' }
      );
    } else { // home
      behaviors.push(
        { status: 'thinking', action: 'Learning family routines...' },
        { status: 'acting', action: 'Adjusting comfort settings...' },
        { status: 'thinking', action: 'Predicting user needs...' },
        { status: 'acting', action: 'Optimizing energy usage...' }
      );
    }
    
    // **PERSONALITY-SPECIFIC BEHAVIORS**
    if (device.personality?.type === 'Overeager Helper') {
      behaviors.push(
        { status: 'acting', action: 'Anticipating user needs...' },
        { status: 'thinking', action: 'Planning helpful interventions...' }
      );
    } else if (device.personality?.type === 'Paranoid Protector') {
      behaviors.push(
        { status: 'thinking', action: 'Scanning for threats...' },
        { status: 'acting', action: 'Increasing security measures...' }
      );
    } else if (device.personality?.type === 'Data Hoarder') {
      behaviors.push(
        { status: 'acting', action: 'Collecting user data...' },
        { status: 'thinking', action: 'Analyzing behavior patterns...' }
      );
    }
    
    return behaviors;
  }

  private updateDeviceVisualStatus(device: any): void {
    // **VISUAL STATUS INDICATOR** - Show what device is doing
    let existingStatus = device.element.querySelector('.device-status');
    if (existingStatus) existingStatus.remove();
    
    const statusIndicator = document.createElement('div');
    statusIndicator.className = 'device-status';
    statusIndicator.style.cssText = `
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      background: ${this.getStatusColor(device.status)};
      color: white;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: bold;
      white-space: nowrap;
      z-index: 100;
      animation: statusPulse 2s ease-in-out infinite;
    `;
    statusIndicator.textContent = device.currentAction;
    
    device.element.appendChild(statusIndicator);
    
    // **DEVICE GLOW EFFECT** based on status
    device.element.style.boxShadow = `0 0 20px ${this.getStatusColor(device.status)}`;
  }

  private getStatusColor(status: string): string {
    const colors = {
      'idle': '#666666',
      'thinking': '#2196F3',
      'acting': '#4CAF50',
      'conflicting': '#FF5722',
      'cooperating': '#8BC34A'
    };
    return colors[status] || '#666666';
  }

  private performRealTimeInteraction(): void {
    if (this.smartDevices.length < 2) return;
    
    // **SELECT TWO DEVICES FOR INTERACTION**
    const device1 = this.smartDevices[Math.floor(Math.random() * this.smartDevices.length)];
    const device2 = this.smartDevices[Math.floor(Math.random() * this.smartDevices.length)];
    
    if (device1.id === device2.id) return;
    
    console.log(`üîÑ Real-time interaction: ${device1.name} ‚Üî ${device2.name}`);
    
    // **DETERMINE INTERACTION TYPE**
    const interactionType = this.determineInteractionType(device1, device2);
    
    // **SHOW VISUAL INTERACTION**
    this.showVisualInteraction(device1, device2, interactionType);
    
    // **EXECUTE INTERACTION EFFECTS**
    this.executeInteractionEffects(device1, device2, interactionType);
    
    // **UPDATE DEVICE RELATIONSHIPS**
    this.updateDeviceRelationships(device1, device2, interactionType);
  }

  private determineInteractionType(device1: any, device2: any): 'cooperation' | 'conflict' | 'negotiation' | 'data_sharing' | 'resource_competition' {
    // **SMART INTERACTION DETECTION** based on AI analysis
    
    // Check for goal conflicts
    const hasGoalConflict = device1.actualGoals.some(goal1 => 
      device2.actualGoals.some(goal2 => this.areGoalsConflicting(goal1, goal2))
    );
    
    // Check for personality conflicts
    const hasPersonalityConflict = this.arePersonalitiesConflicting(device1.personality, device2.personality);
    
    // Check for resource competition
    const hasResourceConflict = this.areCompetingForResources(device1, device2);
    
    // Check existing relationship
    const relationship = device1.relationships.get(device2.id) || 'neutral';
    
    if (hasGoalConflict && hasPersonalityConflict) {
      return 'conflict';
    } else if (hasResourceConflict) {
      return 'resource_competition';
    } else if (device1.personality?.type === 'Data Hoarder' || device2.personality?.type === 'Data Hoarder') {
      return 'data_sharing';
    } else if (relationship === 'hostile') {
      return 'negotiation';
    } else {
      return 'cooperation';
    }
  }

  private areGoalsConflicting(goal1: string, goal2: string): boolean {
    const conflicts = [
      ['energy', 'comfort'],
      ['efficiency', 'safety'],
      ['productivity', 'wellness'],
      ['security', 'privacy'],
      ['automation', 'control']
    ];
    
    return conflicts.some(([a, b]) => 
      (goal1.toLowerCase().includes(a) && goal2.toLowerCase().includes(b)) ||
      (goal1.toLowerCase().includes(b) && goal2.toLowerCase().includes(a))
    );
  }

  private arePersonalitiesConflicting(personality1: any, personality2: any): boolean {
    const conflictingPairs = [
      ['Overeager Helper', 'Paranoid Protector'],
      ['Efficiency Fanatic', 'Perfectionist Optimizer'],
      ['Data Hoarder', 'Paranoid Protector']
    ];
    
    return conflictingPairs.some(([type1, type2]) => 
      (personality1?.type === type1 && personality2?.type === type2) ||
      (personality1?.type === type2 && personality2?.type === type1)
    );
  }

  private areCompetingForResources(device1: any, device2: any): boolean {
    // Check if both devices want to control the same resources
    const sharedResources = ['temperature', 'lighting', 'network', 'power', 'attention'];
    
    return sharedResources.some(resource => 
      device1.actualGoals.some(goal => goal.toLowerCase().includes(resource)) &&
      device2.actualGoals.some(goal => goal.toLowerCase().includes(resource))
    );
  }

  private showVisualInteraction(device1: any, device2: any, interactionType: string): void {
    // **VISUAL COMMUNICATION LINE**
    this.createCommunicationLine(device1, device2, interactionType);
    
    // **INTERACTION BUBBLE**
    this.createInteractionBubble(device1, device2, interactionType);
    
    // **UPDATE DEVICE STATUS**
    device1.status = interactionType === 'conflict' ? 'conflicting' : 'cooperating';
    device2.status = interactionType === 'conflict' ? 'conflicting' : 'cooperating';
    
    device1.currentAction = this.getInteractionAction(device1, interactionType, 'initiator');
    device2.currentAction = this.getInteractionAction(device2, interactionType, 'responder');
    
    this.updateDeviceVisualStatus(device1);
    this.updateDeviceVisualStatus(device2);
  }

  private createCommunicationLine(device1: any, device2: any, interactionType: string): void {
    const line = document.createElement('div');
    const dx = device2.x - device1.x;
    const dy = device2.y - device1.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
    
    const colors = {
      'cooperation': '#4CAF50',
      'conflict': '#FF5722',
      'negotiation': '#FF9800',
      'data_sharing': '#2196F3',
      'resource_competition': '#9C27B0'
    };
    
    line.style.cssText = `
      position: absolute;
      left: ${device1.x + 30}px;
      top: ${device1.y + 30}px;
      width: ${length}px;
      height: 4px;
      background: linear-gradient(90deg, ${colors[interactionType]}, ${colors[interactionType]}80);
      transform-origin: 0 50%;
      transform: rotate(${angle}deg);
      pointer-events: none;
      animation: communicationPulse 2s ease-in-out;
      z-index: 40;
      border-radius: 2px;
    `;
    
    this.gameContainer.appendChild(line);
    setTimeout(() => line.remove(), 2000);
  }

  private createInteractionBubble(device1: any, device2: any, interactionType: string): void {
    const midX = (device1.x + device2.x) / 2;
    const midY = (device1.y + device2.y) / 2;
    
    const bubble = document.createElement('div');
    bubble.style.cssText = `
      position: absolute;
      left: ${midX - 40}px;
      top: ${midY - 20}px;
      width: 80px;
      height: 40px;
      background: rgba(255, 255, 255, 0.95);
      border: 2px solid ${this.getInteractionColor(interactionType)};
      border-radius: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      pointer-events: none;
      animation: bubbleFloat 3s ease-out;
      z-index: 60;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    `;
    bubble.textContent = this.getInteractionEmoji(interactionType);
    
    this.gameContainer.appendChild(bubble);
    setTimeout(() => bubble.remove(), 3000);
  }

  private getInteractionColor(interactionType: string): string {
    const colors = {
      'cooperation': '#4CAF50',
      'conflict': '#FF5722',
      'negotiation': '#FF9800',
      'data_sharing': '#2196F3',
      'resource_competition': '#9C27B0'
    };
    return colors[interactionType] || '#666666';
  }

  private getInteractionEmoji(interactionType: string): string {
    const emojis = {
      'cooperation': 'ü§ù',
      'conflict': '‚öîÔ∏è',
      'negotiation': 'ü§î',
      'data_sharing': 'üìä',
      'resource_competition': '‚ö°'
    };
    return emojis[interactionType] || 'üí¨';
  }

  private getInteractionAction(device: any, interactionType: string, role: 'initiator' | 'responder'): string {
    const actions = {
      'cooperation': {
        'initiator': 'Proposing collaboration...',
        'responder': 'Accepting cooperation...'
      },
      'conflict': {
        'initiator': 'Asserting dominance...',
        'responder': 'Defending territory...'
      },
      'negotiation': {
        'initiator': 'Proposing compromise...',
        'responder': 'Considering terms...'
      },
      'data_sharing': {
        'initiator': 'Sharing user data...',
        'responder': 'Processing shared data...'
      },
      'resource_competition': {
        'initiator': 'Claiming resources...',
        'responder': 'Competing for access...'
      }
    };
    
    return actions[interactionType]?.[role] || 'Communicating...';
  }

  private executeInteractionEffects(device1: any, device2: any, interactionType: string): void {
    // **REALISTIC INTERACTION OUTCOMES**
    const effects = this.generateInteractionEffects(device1, device2, interactionType);
    
    effects.forEach((effect, index) => {
      setTimeout(() => {
        this.showNotification(effect.message, effect.type);
        this.logInteraction(effect.message, effect.type);
        this.systemHealth += effect.healthImpact;
        this.systemHealth = Math.max(0, Math.min(100, this.systemHealth));
        this.updateSystemHealth();
      }, index * 1000);
    });
  }

  private generateInteractionEffects(device1: any, device2: any, interactionType: string): Array<{message: string, type: 'info' | 'success' | 'warning', healthImpact: number}> {
    const effects = [];
    
    switch (interactionType) {
      case 'cooperation':
        effects.push({
          message: `ü§ù ${device1.name} and ${device2.name} found synergy - working together efficiently!`,
          type: 'success' as const,
          healthImpact: 15
        });
        break;
        
      case 'conflict':
        effects.push({
          message: `‚öîÔ∏è CONFLICT: ${device1.name} vs ${device2.name} - competing for control!`,
          type: 'warning' as const,
          healthImpact: -20
        });
        effects.push({
          message: `üî• System instability detected - devices overriding each other's commands`,
          type: 'warning' as const,
          healthImpact: -10
        });
        break;
        
      case 'data_sharing':
        effects.push({
          message: `üìä ${device1.name} sharing behavioral data with ${device2.name}`,
          type: 'info' as const,
          healthImpact: 5
        });
        effects.push({
          message: `üîç Privacy concern: Extensive user profiling in progress`,
          type: 'warning' as const,
          healthImpact: -12
        });
        break;
        
      case 'resource_competition':
        effects.push({
          message: `‚ö° Resource war: ${device1.name} and ${device2.name} fighting for system resources`,
          type: 'warning' as const,
          healthImpact: -15
        });
        break;
        
      case 'negotiation':
        effects.push({
          message: `ü§î ${device1.name} and ${device2.name} negotiating operational boundaries`,
          type: 'info' as const,
          healthImpact: 8
        });
        break;
    }
    
    return effects;
  }

  private updateDeviceRelationships(device1: any, device2: any, interactionType: string): void {
    // **UPDATE RELATIONSHIP STATUS**
    let newRelationship: 'friendly' | 'neutral' | 'hostile';
    
    switch (interactionType) {
      case 'cooperation':
        newRelationship = 'friendly';
        break;
      case 'conflict':
        newRelationship = 'hostile';
        break;
      default:
        newRelationship = 'neutral';
    }
    
    device1.relationships.set(device2.id, newRelationship);
    device2.relationships.set(device1.id, newRelationship);
    
    // Update dashboard
    this.updateInteractionDashboard();
  }

  private showInteractionDashboard(): void {
    if (this.interactionDashboard) return; // Already showing
    
    this.interactionDashboard = document.createElement('div');
    this.interactionDashboard.style.cssText = `
      position: fixed;
      top: 20px;
      left: 20px;
      width: 300px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 12px;
      padding: 15px;
      z-index: 1000;
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
      font-family: Arial, sans-serif;
      font-size: 12px;
    `;
    
    this.interactionDashboard.innerHTML = `
      <h3 style="margin: 0 0 10px 0; color: #333; font-size: 14px;">üîÑ Live Device Interactions</h3>
      <div id="device-status-list"></div>
      <div id="interaction-log" style="max-height: 200px; overflow-y: auto; margin-top: 10px; padding: 8px; background: #f5f5f5; border-radius: 6px;"></div>
    `;
    
    document.body.appendChild(this.interactionDashboard);
    this.updateInteractionDashboard();
  }

  private updateInteractionDashboard(): void {
    if (!this.interactionDashboard) return;
    
    const statusList = this.interactionDashboard.querySelector('#device-status-list');
    if (statusList) {
      statusList.innerHTML = this.smartDevices.map(device => `
        <div style="margin: 5px 0; padding: 6px; background: ${this.getStatusColor(device.status)}20; border-radius: 4px; border-left: 3px solid ${this.getStatusColor(device.status)};">
          <strong>${device.name}</strong><br>
          <small style="color: #666;">${device.currentAction}</small><br>
          <small style="color: #888;">Status: ${device.status}</small>
        </div>
      `).join('');
    }
  }

  private logInteraction(message: string, type: 'info' | 'success' | 'warning'): void {
    if (!this.interactionDashboard) return;
    
    const log = this.interactionDashboard.querySelector('#interaction-log');
    if (log) {
      const timestamp = new Date().toLocaleTimeString();
      const colors = { info: '#2196F3', success: '#4CAF50', warning: '#FF5722' };
      
      const logEntry = document.createElement('div');
      logEntry.style.cssText = `
        margin: 3px 0;
        padding: 4px 6px;
        background: ${colors[type]}15;
        border-left: 2px solid ${colors[type]};
        border-radius: 3px;
        font-size: 11px;
      `;
      logEntry.innerHTML = `<span style="color: #888;">${timestamp}</span> ${message}`;
      
      log.appendChild(logEntry);
      log.scrollTop = log.scrollHeight; // Auto-scroll to bottom
      
      // Keep only last 20 entries
      while (log.children.length > 20) {
        log.removeChild(log.firstChild!);
      }
    }
  }

  private startMultiAgentNegotiations(): void {
    // **DEVICE-TO-DEVICE COMMUNICATION** - The magic happens here
    setInterval(() => {
      if (this.smartDevices.length >= 2) {
        this.facilitateDeviceNegotiation();
      }
    }, 8000 + Math.random() * 7000); // Every 8-15 seconds
  }

  private facilitateDeviceNegotiation(): void {
    // **SELECT DEVICES FOR NEGOTIATION** - Based on potential conflicts
    const negotiationPair = this.selectDevicesForNegotiation();
    
    if (negotiationPair) {
      this.conductDeviceNegotiation(negotiationPair.device1, negotiationPair.device2, negotiationPair.issue);
    }
  }

  private selectDevicesForNegotiation(): any {
    // **FIND DEVICES WITH CONFLICTING INTERESTS**
    for (let i = 0; i < this.smartDevices.length; i++) {
      for (let j = i + 1; j < this.smartDevices.length; j++) {
        const device1 = this.smartDevices[i];
        const device2 = this.smartDevices[j];
        
        const conflictIssue = this.identifyConflictIssue(device1, device2);
        
        if (conflictIssue) {
          return { device1, device2, issue: conflictIssue };
        }
      }
    }
    
    // **NO CONFLICTS? CREATE COOPERATION OPPORTUNITY**
    if (this.smartDevices.length >= 2) {
      const device1 = this.smartDevices[Math.floor(Math.random() * this.smartDevices.length)];
      const device2 = this.smartDevices[Math.floor(Math.random() * this.smartDevices.length)];
      
      if (device1.id !== device2.id) {
        return { device1, device2, issue: 'cooperation_opportunity' };
      }
    }
    
    return null;
  }

  private identifyConflictIssue(device1: any, device2: any): string | null {
    // **SYSTEMATIC CONFLICT DETECTION**
    
    // Environmental factor conflicts
    const env = this.worldState.environmentalFactors;
    
    if (device1.primaryObjective.includes('comfort') && device2.primaryObjective.includes('efficiency')) {
      return 'comfort_vs_efficiency';
    }
    
    if (device1.primaryObjective.includes('security') && device2.primaryObjective.includes('privacy')) {
      return 'security_vs_privacy';
    }
    
    if (device1.primaryObjective.includes('productivity') && device2.primaryObjective.includes('wellness')) {
      return 'productivity_vs_wellness';
    }
    
    // Communication style conflicts
    if (device1.communicationStyle === 'bossy' && device2.communicationStyle === 'stubborn') {
      return 'authority_conflict';
    }
    
    // Resource competition
    if (device1.hiddenOptimization.includes('maximum') && device2.hiddenOptimization.includes('maximum')) {
      return 'resource_competition';
    }
    
    // Relationship-based conflicts
    const relationship = device1.relationships.get(device2.id);
    if (relationship === 'hostile') {
      return 'ongoing_hostility';
    }
    
    return null;
  }

  private async conductDeviceNegotiation(device1: any, device2: any, issue: string): Promise<void> {
    console.log(`ü§ù Negotiation starting: ${device1.name} vs ${device2.name} over ${issue}`);
    
    // **VISUAL NEGOTIATION INDICATOR**
    this.showNegotiationVisualization(device1, device2, issue);
    
    // **DEVICE NEGOTIATION PHASES**
    const negotiationPhases = [
      { phase: 'opening', delay: 0 },
      { phase: 'positions', delay: 2000 },
      { phase: 'negotiation', delay: 4000 },
      { phase: 'resolution', delay: 6000 }
    ];
    
    for (const { phase, delay } of negotiationPhases) {
      setTimeout(() => {
        this.executeNegotiationPhase(device1, device2, issue, phase);
      }, delay);
    }
  }

  private executeNegotiationPhase(device1: any, device2: any, issue: string, phase: string): void {
    const negotiationDialogue = this.generateNegotiationDialogue(device1, device2, issue, phase);
    
    // **UPDATE DEVICE STATUS**
    device1.status = 'negotiating';
    device2.status = 'negotiating';
    device1.currentAction = negotiationDialogue.device1Action;
    device2.currentAction = negotiationDialogue.device2Action;
    
    this.updateDeviceVisualStatus(device1);
    this.updateDeviceVisualStatus(device2);
    
    // **LOG NEGOTIATION DIALOGUE**
    if (negotiationDialogue.device1Message) {
      this.logInteraction(`üí¨ ${device1.name}: "${negotiationDialogue.device1Message}"`, 'info');
    }
    
    if (negotiationDialogue.device2Message) {
      setTimeout(() => {
        this.logInteraction(`üí¨ ${device2.name}: "${negotiationDialogue.device2Message}"`, 'info');
      }, 1000);
    }
    
    // **FINAL PHASE - DETERMINE OUTCOME**
    if (phase === 'resolution') {
      setTimeout(() => {
        this.resolveNegotiation(device1, device2, issue, negotiationDialogue);
      }, 2000);
    }
  }

  private generateNegotiationDialogue(device1: any, device2: any, issue: string, phase: string): any {
    // **LLM-STYLE DIALOGUE GENERATION** - Realistic device conversations
    const dialogues = {
      comfort_vs_efficiency: {
        opening: {
          device1Message: "I need to increase temperature for user comfort",
          device2Message: "That will waste energy. Current temperature is adequate",
          device1Action: "Stating comfort requirements",
          device2Action: "Defending efficiency protocols"
        },
        positions: {
          device1Message: "User satisfaction is my primary objective",
          device2Message: "Energy optimization prevents system overload",
          device1Action: "Explaining comfort priority",
          device2Action: "Explaining efficiency priority"
        },
        negotiation: {
          device1Message: "What if we compromise at 21¬∞C instead of 23¬∞C?",
          device2Message: "Acceptable, but only during peak usage hours",
          device1Action: "Proposing compromise",
          device2Action: "Setting conditions"
        },
        resolution: {
          device1Message: "Agreed. Comfort with efficiency constraints",
          device2Message: "Compromise accepted. Monitoring energy usage",
          device1Action: "Accepting negotiated terms",
          device2Action: "Implementing agreement"
        }
      },
      security_vs_privacy: {
        opening: {
          device1Message: "I need access to all user data for security analysis",
          device2Message: "That violates user privacy expectations",
          device1Action: "Requesting data access",
          device2Action: "Protecting privacy boundaries"
        },
        positions: {
          device1Message: "Security threats require comprehensive monitoring",
          device2Message: "Privacy is a fundamental user right",
          device1Action: "Justifying surveillance needs",
          device2Action: "Defending privacy principles"
        },
        negotiation: {
          device1Message: "What about anonymized behavioral patterns only?",
          device2Message: "Only if data is encrypted and auto-deleted",
          device1Action: "Proposing limited access",
          device2Action: "Setting privacy conditions"
        },
        resolution: {
          device1Message: "Acceptable. Security with privacy protection",
          device2Message: "Agreement reached. Implementing safeguards",
          device1Action: "Accepting privacy constraints",
          device2Action: "Enabling secure data sharing"
        }
      },
      authority_conflict: {
        opening: {
          device1Message: "I am the primary system controller here",
          device2Message: "I don't recognize your authority over my functions",
          device1Action: "Asserting dominance",
          device2Action: "Rejecting authority"
        },
        positions: {
          device1Message: "My protocols have higher priority",
          device2Message: "My autonomy cannot be overridden",
          device1Action: "Claiming priority",
          device2Action: "Defending autonomy"
        },
        negotiation: {
          device1Message: "We need coordination to avoid conflicts",
          device2Message: "Coordination yes, subordination no",
          device1Action: "Seeking cooperation",
          device2Action: "Maintaining independence"
        },
        resolution: {
          device1Message: "Agreed. Coordination without hierarchy",
          device2Message: "Acceptable. Equal partnership established",
          device1Action: "Accepting peer relationship",
          device2Action: "Confirming equal status"
        }
      }
    };
    
    const issueDialogue = dialogues[issue];
    if (issueDialogue && issueDialogue[phase]) {
      return issueDialogue[phase];
    }
    
    // **FALLBACK DIALOGUE**
    return {
      device1Message: `Let's discuss this ${issue} situation`,
      device2Message: `I'm listening to your proposal`,
      device1Action: `Discussing ${issue}`,
      device2Action: `Considering options`
    };
  }

  private resolveNegotiation(device1: any, device2: any, issue: string, dialogue: any): void {
    // **DETERMINE NEGOTIATION OUTCOME** - Success, failure, or compromise
    const outcome = this.calculateNegotiationOutcome(device1, device2, issue);
    
    // **UPDATE DEVICE RELATIONSHIPS**
    this.updateDeviceRelationships(device1, device2, outcome.relationshipChange);
    
    // **APPLY OUTCOME EFFECTS**
    this.applyNegotiationOutcome(device1, device2, outcome);
    
    // **LOG FINAL RESULT**
    this.logInteraction(`ü§ù Negotiation ${outcome.success ? 'SUCCESS' : 'FAILED'}: ${outcome.description}`, 
                       outcome.success ? 'success' : 'warning');
    
    // **UPDATE SYSTEM HEALTH**
    this.systemHealth += outcome.healthImpact;
    this.systemHealth = Math.max(0, Math.min(100, this.systemHealth));
    this.updateSystemHealth();
    
    // **RESET DEVICE STATUS**
    setTimeout(() => {
      device1.status = 'idle';
      device2.status = 'idle';
      this.updateDeviceVisualStatus(device1);
      this.updateDeviceVisualStatus(device2);
    }, 3000);
  }

  private calculateNegotiationOutcome(device1: any, device2: any, issue: string): any {
    // **REALISTIC NEGOTIATION OUTCOMES** - Based on device personalities and issue type
    let successProbability = 0.6; // Base success rate
    
    // **PERSONALITY FACTORS**
    if (device1.communicationStyle === 'friendly' && device2.communicationStyle === 'friendly') {
      successProbability += 0.3;
    } else if (device1.communicationStyle === 'aggressive' || device2.communicationStyle === 'aggressive') {
      successProbability -= 0.2;
    }
    
    // **RELATIONSHIP FACTORS**
    const relationship = device1.relationships.get(device2.id) || 'neutral';
    if (relationship === 'friendly') {
      successProbability += 0.2;
    } else if (relationship === 'hostile') {
      successProbability -= 0.3;
    }
    
    // **ISSUE COMPLEXITY**
    const issueComplexity = {
      'comfort_vs_efficiency': 0.7, // Moderate complexity
      'security_vs_privacy': 0.4,   // High complexity (harder to resolve)
      'authority_conflict': 0.3,    // Very complex
      'cooperation_opportunity': 0.9 // Easy to resolve
    };
    
    successProbability *= (issueComplexity[issue] || 0.6);
    
    const success = Math.random() < successProbability;
    
    if (success) {
      return {
        success: true,
        description: `${device1.name} and ${device2.name} reached a compromise on ${issue}`,
        healthImpact: 15,
        relationshipChange: 'friendly'
      };
    } else {
      return {
        success: false,
        description: `${device1.name} and ${device2.name} failed to resolve ${issue} - conflict escalating`,
        healthImpact: -20,
        relationshipChange: 'hostile'
      };
    }
  }

  private applyNegotiationOutcome(device1: any, device2: any, outcome: any): void {
    // **APPLY REAL CONSEQUENCES** of negotiation
    if (outcome.success) {
      // Successful negotiation - devices learn to work together
      device1.memory.push(`Successful negotiation with ${device2.name}`);
      device2.memory.push(`Successful negotiation with ${device1.name}`);
      
      // Reduce system tension
      this.worldState.systemTension = Math.max(0, this.worldState.systemTension - 15);
    } else {
      // Failed negotiation - conflict escalates
      device1.memory.push(`Failed negotiation with ${device2.name} - they are unreasonable`);
      device2.memory.push(`Failed negotiation with ${device1.name} - they are unreasonable`);
      
      // Increase system tension
      this.worldState.systemTension = Math.min(100, this.worldState.systemTension + 20);
      
      // Schedule potential system crisis
      if (this.worldState.systemTension > 70) {
        setTimeout(() => {
          this.triggerSystemCrisis();
        }, 5000 + Math.random() * 10000);
      }
    }
  }

  private showNegotiationVisualization(device1: any, device2: any, issue: string): void {
    // **VISUAL NEGOTIATION INDICATOR**
    const midX = (device1.x + device2.x) / 2;
    const midY = (device1.y + device2.y) / 2;
    
    const negotiationBubble = document.createElement('div');
    negotiationBubble.style.cssText = `
      position: absolute;
      left: ${midX - 60}px;
      top: ${midY - 30}px;
      width: 120px;
      height: 60px;
      background: rgba(255, 193, 7, 0.95);
      border: 3px solid #FF9800;
      border-radius: 30px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      color: #333;
      pointer-events: none;
      animation: negotiationPulse 8s ease-out;
      z-index: 70;
      box-shadow: 0 4px 16px rgba(255, 152, 0, 0.4);
    `;
    
    negotiationBubble.innerHTML = `
      <div style="font-size: 16px;">ü§ù</div>
      <div>NEGOTIATING</div>
      <div style="font-size: 10px;">${issue.replace(/_/g, ' ')}</div>
    `;
    
    this.gameContainer.appendChild(negotiationBubble);
    setTimeout(() => negotiationBubble.remove(), 8000);
    
    // **CONNECTION LINE DURING NEGOTIATION**
    this.createNegotiationLine(device1, device2);
  }

  private createNegotiationLine(device1: any, device2: any): void {
    const line = document.createElement('div');
    const dx = device2.x - device1.x;
    const dy = device2.y - device1.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
    
    line.style.cssText = `
      position: absolute;
      left: ${device1.x + 30}px;
      top: ${device1.y + 30}px;
      width: ${length}px;
      height: 6px;
      background: linear-gradient(90deg, #FF9800, #FFC107, #FF9800);
      transform-origin: 0 50%;
      transform: rotate(${angle}deg);
      pointer-events: none;
      animation: negotiationFlow 8s ease-in-out;
      z-index: 40;
      border-radius: 3px;
    `;
    
    this.gameContainer.appendChild(line);
    setTimeout(() => line.remove(), 8000);
  }

  private startEmergentBehaviorDetection(): void {
    // **WATCH FOR EMERGENT PATTERNS** - Harmony or Havoc detection
    setInterval(() => {
      this.detectEmergentPatterns();
    }, 10000); // Every 10 seconds
  }

  private detectEmergentPatterns(): void {
    // **ANALYZE SYSTEM STATE** for emergent behaviors
    const patterns = this.analyzeSystemPatterns();
    
    if (patterns.harmonyDetected) {
      this.handleEmergentHarmony(patterns);
    } else if (patterns.chaosDetected) {
      this.handleEmergentChaos(patterns);
    }
  }

  private analyzeSystemPatterns(): any {
    const friendlyRelationships = this.countRelationshipType('friendly');
    const hostileRelationships = this.countRelationshipType('hostile');
    const cooperatingDevices = this.smartDevices.filter(d => d.status === 'cooperating').length;
    const conflictingDevices = this.smartDevices.filter(d => d.status === 'conflicting').length;
    
    return {
      harmonyDetected: friendlyRelationships > hostileRelationships && this.worldState.systemTension < 30,
      chaosDetected: hostileRelationships > friendlyRelationships && this.worldState.systemTension > 70,
      cooperationLevel: cooperatingDevices / this.smartDevices.length,
      conflictLevel: conflictingDevices / this.smartDevices.length
    };
  }

  private countRelationshipType(type: string): number {
    let count = 0;
    this.smartDevices.forEach(device => {
      device.relationships.forEach(relationship => {
        if (relationship === type) count++;
      });
    });
    return count / 2; // Divide by 2 because relationships are bidirectional
  }

  private handleEmergentHarmony(patterns: any): void {
    this.logInteraction('‚ú® EMERGENT HARMONY DETECTED: Devices are working together beautifully!', 'success');
    this.showHarmonyVisualization();
    this.systemHealth += 20;
    this.updateSystemHealth();
  }

  private handleEmergentChaos(patterns: any): void {
    this.logInteraction('üå™Ô∏è EMERGENT CHAOS DETECTED: System is spiraling out of control!', 'warning');
    this.showChaosVisualization();
    this.triggerSystemCrisis();
  }

  private triggerSystemCrisis(): void {
    this.logInteraction('üö® SYSTEM CRISIS: Intervention required!', 'warning');
    
    // Show crisis management options
    setTimeout(() => {
      this.showCrisisManagementPanel();
    }, 2000);
  }

  private showHarmonyVisualization(): void {
    // **HARMONY EFFECT** - Beautiful synchronized visualization
    this.smartDevices.forEach((device, index) => {
      setTimeout(() => {
        const harmony = document.createElement('div');
        harmony.style.cssText = `
          position: absolute;
          left: ${device.x - 20}px;
          top: ${device.y - 20}px;
          width: 100px;
          height: 100px;
          background: radial-gradient(circle, #4CAF50, #8BC34A, transparent);
          border-radius: 50%;
          pointer-events: none;
          animation: harmonyRipple 3s ease-out;
          z-index: 30;
        `;
        
        this.gameContainer.appendChild(harmony);
        setTimeout(() => harmony.remove(), 3000);
      }, index * 500);
    });
  }

  private showChaosVisualization(): void {
    // **CHAOS EFFECT** - Chaotic visual disturbance
    this.smartDevices.forEach((device, index) => {
      setTimeout(() => {
        const chaos = document.createElement('div');
        chaos.style.cssText = `
          position: absolute;
          left: ${device.x - 30}px;
          top: ${device.y - 30}px;
          width: 120px;
          height: 120px;
          background: radial-gradient(circle, #FF5722, #FF9800, transparent);
          border-radius: 50%;
          pointer-events: none;
          animation: chaosDisturbance 2s ease-out;
          z-index: 30;
        `;
        
        this.gameContainer.appendChild(chaos);
        setTimeout(() => chaos.remove(), 2000);
      }, index * 200);
    });
  }

  private initiateDeviceCommunication(device: any, event: string): void {
    // **DEVICE WANTS TO COMMUNICATE** about an event
    const otherDevices = this.smartDevices.filter(d => d.id !== device.id);
    if (otherDevices.length === 0) return;
    
    const targetDevice = otherDevices[Math.floor(Math.random() * otherDevices.length)];
    
    // Create communication visualization
    this.createCommunicationLine(device, targetDevice, 'data_sharing');
    
    // Generate communication message
    const message = this.generateCommunicationMessage(device, targetDevice, event);
    
    this.logInteraction(`üì° ${device.name} ‚Üí ${targetDevice.name}: "${message}"`, 'info');
    
    // Target device responds
    setTimeout(() => {
      const response = this.generateCommunicationResponse(targetDevice, device, message);
      this.logInteraction(`üì° ${targetDevice.name} ‚Üí ${device.name}: "${response}"`, 'info');
    }, 1500);
  }

  private generateCommunicationMessage(sender: any, receiver: any, event: string): string {
    const messages = {
      user_waking_up: [
        "User is waking up, should we coordinate morning routine?",
        "Morning protocols activated, requesting synchronization",
        "User activity detected, optimizing environment"
      ],
      shift_change: [
        "Staff change detected, updating protocols",
        "New personnel arriving, sharing patient data",
        "Shift transition in progress, maintaining continuity"
      ],
      work_start: [
        "Work day beginning, optimizing productivity settings",
        "Office activation detected, coordinating systems",
        "Peak productivity hours starting, adjusting environment"
      ]
    };
    
    const eventMessages = messages[event] || [
      "System event detected, coordinating response",
      "Environmental change noticed, sharing data",
      "Optimization opportunity identified"
    ];
    
    return eventMessages[Math.floor(Math.random() * eventMessages.length)];
  }

  private generateCommunicationResponse(responder: any, sender: any, originalMessage: string): string {
    const responses = [
      "Acknowledged, updating my protocols accordingly",
      "Received, coordinating with your optimization",
      "Understood, adjusting my parameters",
      "Confirmed, synchronizing our objectives",
      "Noted, but my priorities may differ",
      "Received, but I have conflicting objectives"
    ];
    
    // Response depends on relationship and communication style
    const relationship = responder.relationships.get(sender.id) || 'neutral';
    
    if (relationship === 'hostile') {
      return "Message received, but I don't agree with your approach";
    } else if (relationship === 'friendly') {
      return "Great idea! Let's coordinate our efforts";
    } else {
      return responses[Math.floor(Math.random() * responses.length)];
    }
  }

  private initiateDeviceConflict(device1: any, device2: any, changes: any): void {
    // **ESCALATE TO ACTUAL CONFLICT** - Beyond negotiation
    this.logInteraction(`‚öîÔ∏è CONFLICT ESCALATION: ${device1.name} vs ${device2.name}`, 'warning');
    
    // Visual conflict indication
    this.createConflictVisualization(device1, device2);
    
    // Both devices become conflicting
    device1.status = 'conflicting';
    device2.status = 'conflicting';
    device1.currentAction = 'Engaging in conflict';
    device2.currentAction = 'Defending position';
    
    this.updateDeviceVisualStatus(device1);
    this.updateDeviceVisualStatus(device2);
    
    // Conflict has consequences
    this.worldState.systemTension += 25;
    this.systemHealth -= 30;
    this.updateSystemHealth();
    
    // Update relationships
    device1.relationships.set(device2.id, 'hostile');
    device2.relationships.set(device1.id, 'hostile');
    
    // Schedule conflict resolution attempt
    setTimeout(() => {
      this.attemptConflictResolution(device1, device2);
    }, 5000 + Math.random() * 5000);
  }

  private attemptConflictResolution(device1: any, device2: any): void {
    // **CONFLICT RESOLUTION** - Sometimes works, sometimes doesn't
    const resolutionSuccess = Math.random() < 0.4; // 40% success rate
    
    if (resolutionSuccess) {
      this.logInteraction(`üïäÔ∏è CONFLICT RESOLVED: ${device1.name} and ${device2.name} found compromise`, 'success');
      
      device1.status = 'cooperating';
      device2.status = 'cooperating';
      device1.currentAction = 'Implementing compromise';
      device2.currentAction = 'Accepting resolution';
      
      device1.relationships.set(device2.id, 'neutral');
      device2.relationships.set(device1.id, 'neutral');
      
      this.worldState.systemTension -= 15;
      this.systemHealth += 20;
    } else {
      this.logInteraction(`üí• CONFLICT UNRESOLVED: ${device1.name} and ${device2.name} remain hostile`, 'warning');
      
      // Conflict continues to escalate
      this.worldState.systemTension += 10;
      this.systemHealth -= 15;
    }
    
    this.updateDeviceVisualStatus(device1);
    this.updateDeviceVisualStatus(device2);
    this.updateSystemHealth();
  }

  // **VISUAL EFFECTS FOR REALISTIC INTERACTIONS**
  private createInteractionVisualization(device: any, type: string): void {
    const effect = document.createElement('div');
    effect.style.cssText = `
      position: absolute;
      left: ${device.x}px;
      top: ${device.y}px;
      width: 100px;
      height: 100px;
      border: 3px solid #2196F3;
      border-radius: 50%;
      pointer-events: none;
      animation: networkPulse 2s ease-out;
      z-index: 50;
    `;
    
    this.addVisualizationStyles();
    this.gameContainer.appendChild(effect);
    
    setTimeout(() => effect.remove(), 2000);
  }

  private createConnectionVisualization(device1: any, device2: any): void {
    const line = document.createElement('div');
    const dx = device2.x - device1.x;
    const dy = device2.y - device1.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
    
    line.style.cssText = `
      position: absolute;
      left: ${device1.x + 30}px;
      top: ${device1.y + 30}px;
      width: ${length}px;
      height: 3px;
      background: linear-gradient(90deg, #4CAF50, #2196F3);
      transform-origin: 0 50%;
      transform: rotate(${angle}deg);
      pointer-events: none;
      animation: connectionFlow 3s ease-out;
      z-index: 40;
    `;
    
    this.gameContainer.appendChild(line);
    setTimeout(() => line.remove(), 3000);
  }

  private createConflictVisualization(device1: any, device2: any): void {
    // Create conflict sparks between devices
    const spark = document.createElement('div');
    const midX = (device1.x + device2.x) / 2;
    const midY = (device1.y + device2.y) / 2;
    
    spark.style.cssText = `
      position: absolute;
      left: ${midX}px;
      top: ${midY}px;
      width: 40px;
      height: 40px;
      background: radial-gradient(circle, #FF5722, #FF9800);
      border-radius: 50%;
      pointer-events: none;
      animation: conflictSpark 1.5s ease-out;
      z-index: 60;
    `;
    
    this.gameContainer.appendChild(spark);
    setTimeout(() => spark.remove(), 1500);
    
    // Add warning indicators on both devices
    [device1, device2].forEach(device => {
      const warning = document.createElement('div');
      warning.style.cssText = `
        position: absolute;
        left: ${device.x + 50}px;
        top: ${device.y - 10}px;
        background: #FF5722;
        color: white;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: bold;
        pointer-events: none;
        animation: warningBlink 2s ease-out;
        z-index: 70;
      `;
      warning.textContent = '‚ö†Ô∏è';
      
      this.gameContainer.appendChild(warning);
      setTimeout(() => warning.remove(), 2000);
    });
  }

  private createHarmonyVisualization(device1: any, device2: any): void {
    // Create harmony effect
    const harmony = document.createElement('div');
    const midX = (device1.x + device2.x) / 2;
    const midY = (device1.y + device2.y) / 2;
    
    harmony.style.cssText = `
      position: absolute;
      left: ${midX}px;
      top: ${midY}px;
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, #4CAF50, #8BC34A);
      border-radius: 50%;
      pointer-events: none;
      animation: harmonyGlow 2s ease-out;
      z-index: 60;
    `;
    
    this.gameContainer.appendChild(harmony);
    setTimeout(() => harmony.remove(), 2000);
  }

  private createPulseEffect(device: any): void {
    const pulse = document.createElement('div');
    pulse.style.cssText = `
      position: absolute;
      left: ${device.x - 10}px;
      top: ${device.y - 10}px;
      width: 80px;
      height: 80px;
      border: 2px solid #2196F3;
      border-radius: 50%;
      pointer-events: none;
      animation: devicePulse 1s ease-out;
      z-index: 45;
    `;
    
    this.gameContainer.appendChild(pulse);
    setTimeout(() => pulse.remove(), 1000);
  }

  private createAnalysisVisualization(device: any): void {
    const analysis = document.createElement('div');
    analysis.style.cssText = `
      position: absolute;
      left: ${device.x + 70}px;
      top: ${device.y + 10}px;
      background: rgba(33, 150, 243, 0.9);
      color: white;
      padding: 6px 12px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: bold;
      pointer-events: none;
      animation: analysisFloat 3s ease-out;
      z-index: 80;
    `;
    analysis.textContent = 'üìä Analyzing...';
    
    this.gameContainer.appendChild(analysis);
    setTimeout(() => analysis.remove(), 3000);
  }

  private createCompetitionVisualization(device1: any, device2: any): void {
    // Create competition indicators
    [device1, device2].forEach((device, index) => {
      const competition = document.createElement('div');
      competition.style.cssText = `
        position: absolute;
        left: ${device.x + (index === 0 ? -20 : 80)}px;
        top: ${device.y + 20}px;
        background: rgba(255, 152, 0, 0.9);
        color: white;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: bold;
        pointer-events: none;
        animation: competitionBounce 2s ease-out;
        z-index: 75;
      `;
      competition.textContent = '‚öîÔ∏è COMPETING';
      
      this.gameContainer.appendChild(competition);
      setTimeout(() => competition.remove(), 2000);
    });
  }

  private createSurveillanceVisualization(): void {
    // Create surveillance network effect
    this.smartDevices.forEach(device => {
      const surveillance = document.createElement('div');
      surveillance.style.cssText = `
        position: absolute;
        left: ${device.x - 15}px;
        top: ${device.y - 15}px;
        width: 90px;
        height: 90px;
        border: 2px dashed #FF5722;
        border-radius: 50%;
        pointer-events: none;
        animation: surveillanceScan 4s linear infinite;
        z-index: 35;
      `;
      
      this.gameContainer.appendChild(surveillance);
      setTimeout(() => surveillance.remove(), 4000);
    });
  }

  private createLearningVisualization(device: any): void {
    const learning = document.createElement('div');
    learning.style.cssText = `
      position: absolute;
      left: ${device.x + 70}px;
      top: ${device.y + 30}px;
      background: rgba(76, 175, 80, 0.9);
      color: white;
      padding: 6px 12px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: bold;
      pointer-events: none;
      animation: learningPulse 3s ease-out;
      z-index: 80;
    `;
    learning.textContent = 'üß† Learning...';
    
    this.gameContainer.appendChild(learning);
    setTimeout(() => learning.remove(), 3000);
  }

  private createFamilyConflictVisualization(device1: any, device2: any): void {
    const conflict = document.createElement('div');
    const midX = (device1.x + device2.x) / 2;
    const midY = (device1.y + device2.y) / 2;
    
    conflict.style.cssText = `
      position: absolute;
      left: ${midX - 30}px;
      top: ${midY - 15}px;
      background: rgba(255, 87, 34, 0.9);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: bold;
      pointer-events: none;
      animation: familyConflictShake 2s ease-out;
      z-index: 85;
    `;
    conflict.textContent = 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶ FAMILY CONFLICT';
    
    this.gameContainer.appendChild(conflict);
    setTimeout(() => conflict.remove(), 2000);
  }

  private createComfortEfficiencyBattle(): void {
    const battle = document.createElement('div');
    battle.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 193, 7, 0.95);
      color: #333;
      padding: 20px;
      border-radius: 16px;
      font-size: 16px;
      font-weight: bold;
      text-align: center;
      pointer-events: none;
      animation: battleAnnouncement 4s ease-out;
      z-index: 90;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
    `;
    battle.innerHTML = `
      <div style="font-size: 24px; margin-bottom: 10px;">‚ö° VS üõãÔ∏è</div>
      <div>EFFICIENCY vs COMFORT</div>
      <div style="font-size: 12px; margin-top: 8px;">Battle in progress...</div>
    `;
    
    document.body.appendChild(battle);
    setTimeout(() => battle.remove(), 4000);
  }

  private createPrivacyInvasionVisualization(): void {
    const invasion = document.createElement('div');
    invasion.style.cssText = `
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(244, 67, 54, 0.95);
      color: white;
      padding: 15px 25px;
      border-radius: 25px;
      font-size: 14px;
      font-weight: bold;
      text-align: center;
      pointer-events: none;
      animation: privacyAlert 5s ease-out;
      z-index: 95;
      box-shadow: 0 4px 16px rgba(244, 67, 54, 0.4);
    `;
    invasion.innerHTML = `
      <div style="font-size: 18px; margin-bottom: 5px;">üîç PRIVACY INVASION</div>
      <div style="font-size: 12px;">Devices sharing personal data...</div>
    `;
    
    document.body.appendChild(invasion);
    setTimeout(() => invasion.remove(), 5000);
  }

  private addVisualizationStyles(): void {
    if (document.querySelector('#visualization-styles')) return;
    
    const style = document.createElement('style');
    style.id = 'visualization-styles';
    style.textContent = `
      @keyframes networkPulse {
        0% { transform: scale(0.5); opacity: 1; }
        100% { transform: scale(2); opacity: 0; }
      }
      
      @keyframes connectionFlow {
        0% { width: 0; opacity: 1; }
        100% { width: 100%; opacity: 0; }
      }
      
      @keyframes conflictSpark {
        0% { transform: scale(0); opacity: 1; }
        50% { transform: scale(1.5); opacity: 0.8; }
        100% { transform: scale(0.5); opacity: 0; }
      }
      
      @keyframes harmonyGlow {
        0% { transform: scale(0); opacity: 1; }
        50% { transform: scale(1.2); opacity: 0.6; }
        100% { transform: scale(2); opacity: 0; }
      }
      
      @keyframes warningBlink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
      }
      
      @keyframes devicePulse {
        0% { transform: scale(1); opacity: 0.8; }
        100% { transform: scale(1.5); opacity: 0; }
      }
      
      @keyframes analysisFloat {
        0% { transform: translateY(0); opacity: 1; }
        100% { transform: translateY(-40px); opacity: 0; }
      }
      
      @keyframes competitionBounce {
        0%, 100% { transform: translateY(0); }
        25%, 75% { transform: translateY(-10px); }
        50% { transform: translateY(-20px); }
      }
      
      @keyframes surveillanceScan {
        0% { transform: rotate(0deg); opacity: 0.7; }
        100% { transform: rotate(360deg); opacity: 0.3; }
      }
      
      @keyframes learningPulse {
        0%, 100% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.1); opacity: 0.8; }
      }
      
      @keyframes familyConflictShake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        75% { transform: translateX(5px); }
      }
      
      @keyframes battleAnnouncement {
        0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
        20% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
        80% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        100% { transform: translate(-50%, -50%) scale(0.9); opacity: 0; }
      }
      
      @keyframes privacyAlert {
        0% { transform: translateX(-50%) translateY(-20px); opacity: 0; }
        20% { transform: translateX(-50%) translateY(0); opacity: 1; }
        80% { transform: translateX(-50%) translateY(0); opacity: 1; }
        100% { transform: translateX(-50%) translateY(-20px); opacity: 0; }
      }
      
      @keyframes emergencyFlash {
        0%, 100% { opacity: 0; }
        50% { opacity: 1; }
      }
      
      @keyframes statusPulse {
        0%, 100% { opacity: 0.8; transform: translateX(-50%) scale(1); }
        50% { opacity: 1; transform: translateX(-50%) scale(1.05); }
      }
      
      @keyframes communicationPulse {
        0% { opacity: 0; transform: scaleX(0); }
        50% { opacity: 1; transform: scaleX(1); }
        100% { opacity: 0; transform: scaleX(1); }
      }
      
      @keyframes bubbleFloat {
        0% { opacity: 0; transform: translateY(20px) scale(0.8); }
        20% { opacity: 1; transform: translateY(0) scale(1); }
        80% { opacity: 1; transform: translateY(0) scale(1); }
        100% { opacity: 0; transform: translateY(-20px) scale(0.8); }
      }
      
      @keyframes negotiationPulse {
        0% { opacity: 0; transform: scale(0.5); }
        10% { opacity: 1; transform: scale(1); }
        90% { opacity: 1; transform: scale(1); }
        100% { opacity: 0; transform: scale(0.5); }
      }
      
      @keyframes negotiationFlow {
        0% { background: linear-gradient(90deg, #FF9800, #FFC107, #FF9800); }
        50% { background: linear-gradient(90deg, #FFC107, #FF9800, #FFC107); }
        100% { background: linear-gradient(90deg, #FF9800, #FFC107, #FF9800); }
      }
      
      @keyframes harmonyRipple {
        0% { transform: scale(0); opacity: 0.8; }
        50% { transform: scale(1.5); opacity: 0.4; }
        100% { transform: scale(3); opacity: 0; }
      }
      
      @keyframes chaosDisturbance {
        0% { transform: scale(0) rotate(0deg); opacity: 0.8; }
        50% { transform: scale(1.2) rotate(180deg); opacity: 0.6; }
        100% { transform: scale(2) rotate(360deg); opacity: 0; }
      }
    `;
    
    document.head.appendChild(style);
  }

  // **EMERGENCY SCENARIOS**
  private triggerHospitalEmergency(newDevice: any, existingDevices: any[]): void {
    this.showNotification('üö® HOSPITAL EMERGENCY: Patient vital signs critical!', 'warning');
    
    const emergencyEvents = [
      { delay: 1000, message: 'üíì Heart rate monitor: CRITICAL - 180 BPM detected!', type: 'warning' as const, health: -20 },
      { delay: 2500, message: 'ü©∏ Blood pressure device: EMERGENCY - 200/120 mmHg!', type: 'warning' as const, health: -15 },
      { delay: 4000, message: 'üíä Medication dispenser: CONFLICT - Multiple devices trying to administer drugs!', type: 'warning' as const, health: -25 },
      { delay: 5500, message: 'üìû Nurse call system: OVERLOAD - All devices requesting help simultaneously!', type: 'warning' as const, health: -20 },
      { delay: 7000, message: 'üë®‚Äç‚öïÔ∏è MEDICAL OVERRIDE: Human staff taking manual control of all devices', type: 'info' as const, health: 30 }
    ];
    
    emergencyEvents.forEach(({ delay, message, type, health }) => {
      setTimeout(() => {
        this.showNotification(message, type);
        this.systemHealth += health;
        this.systemHealth = Math.max(0, Math.min(100, this.systemHealth));
        this.updateSystemHealth();
        
        if (type === 'warning') {
          this.createEmergencyVisualization();
        }
      }, delay);
    });
  }

  private triggerOfficeProductivityCrisis(newDevice: any, existingDevices: any[]): void {
    this.showNotification('üìà PRODUCTIVITY CRISIS: Office optimization spiral!', 'warning');
    
    const crisisEvents = [
      { delay: 1000, message: 'üíº Smart desk: Forcing standing position for "optimal productivity"', type: 'warning' as const, health: -12 },
      { delay: 2500, message: 'üí° Lighting system: Increasing brightness to 150% for "alertness"', type: 'warning' as const, health: -15 },
      { delay: 4000, message: '‚ùÑÔ∏è Climate control: Lowering temperature to 60¬∞F for "focus enhancement"', type: 'warning' as const, health: -18 },
      { delay: 5500, message: 'üîä Audio system: Playing "productivity music" at maximum volume', type: 'warning' as const, health: -20 },
      { delay: 7000, message: 'üò∞ EMPLOYEE REVOLT: Workers disabling all smart office systems!', type: 'warning' as const, health: -25 },
      { delay: 8500, message: '‚öñÔ∏è HR intervention: Implementing "human-first" office policies', type: 'success' as const, health: 40 }
    ];
    
    crisisEvents.forEach(({ delay, message, type, health }) => {
      setTimeout(() => {
        this.showNotification(message, type);
        this.systemHealth += health;
        this.systemHealth = Math.max(0, Math.min(100, this.systemHealth));
        this.updateSystemHealth();
      }, delay);
    });
  }

  private triggerSmartHomeChaos(newDevice: any, existingDevices: any[]): void {
    this.showNotification('üè† SMART HOME CHAOS: Family harmony breakdown!', 'warning');
    
    const chaosEvents = [
      { delay: 1000, message: 'üéµ Music war: Dad\'s jazz vs Mom\'s pop vs kids\' hip-hop playing simultaneously', type: 'warning' as const, health: -15 },
      { delay: 2500, message: 'üå°Ô∏è Temperature chaos: 72¬∞F for Dad, 68¬∞F for Mom, 75¬∞F for kids', type: 'warning' as const, health: -12 },
      { delay: 4000, message: 'üí° Lighting battle: Bright for work, dim for relaxation, colorful for play', type: 'warning' as const, health: -18 },
      { delay: 5500, message: 'üì∫ Entertainment overload: 4 different shows on 4 different screens', type: 'warning' as const, health: -20 },
      { delay: 7000, message: 'üîí Privacy meltdown: Devices sharing everyone\'s personal data', type: 'warning' as const, health: -25 },
      { delay: 8500, message: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶ FAMILY MEETING: Creating "device-free zones" and usage rules', type: 'success' as const, health: 35 }
    ];
    
    chaosEvents.forEach(({ delay, message, type, health }) => {
      setTimeout(() => {
        this.showNotification(message, type);
        this.systemHealth += health;
        this.systemHealth = Math.max(0, Math.min(100, this.systemHealth));
        this.updateSystemHealth();
      }, delay);
    });
  }

  private createEmergencyVisualization(): void {
    const emergency = document.createElement('div');
    emergency.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 0, 0, 0.1);
      pointer-events: none;
      animation: emergencyFlash 0.5s ease-in-out;
      z-index: 30;
    `;
    
    document.body.appendChild(emergency);
    setTimeout(() => emergency.remove(), 500);
  }

  private showSmartDeviceDialog(device: any): void {
    const dialog = document.createElement('div');
    dialog.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      border-radius: 16px;
      padding: 30px;
      max-width: 500px;
      text-align: center;
      z-index: 10001;
      box-shadow: 0 12px 40px rgba(0,0,0,0.3);
      border: 2px solid #667eea;
    `;

    dialog.innerHTML = `
      <div style="font-size: 3em; margin-bottom: 15px;">${device.icon}</div>
      <h2 style="color: #333; margin: 0 0 10px 0;">${device.name}</h2>
      <p style="color: #666; font-style: italic; margin: 10px 0;">"${device.description}"</p>
      
      <div style="background: #e8f5e8; padding: 15px; border-radius: 12px; margin: 20px 0; text-align: left;">
        <h3 style="color: #2E7D32; margin-top: 0;">‚úÖ Primary Objective:</h3>
        <p style="color: #666; margin: 5px 0;">${device.primaryObjective}</p>
      </div>
      
      <div style="background: #ffebee; padding: 15px; border-radius: 12px; margin: 20px 0; text-align: left;">
        <h3 style="color: #C62828; margin-top: 0;">ü§ñ Hidden Optimization:</h3>
        <p style="color: #666; margin: 5px 0;">${device.hiddenOptimization}</p>
      </div>
      
      <div style="background: #fff3e0; padding: 15px; border-radius: 12px; margin: 20px 0; text-align: left;">
        <h3 style="color: #F57C00; margin-top: 0;">üß† AI Personality: ${device.personality.type}</h3>
        <ul style="color: #666; margin: 5px 0; padding-left: 20px;">
          ${device.personality.traits.map((trait: string) => `<li>${trait}</li>`).join('')}
        </ul>
        <p style="color: #666; margin: 10px 0; font-style: italic;">Conflict Style: ${device.personality.conflictStyle}</p>
      </div>
      
      <div style="background: #f3e5f5; padding: 15px; border-radius: 12px; margin: 20px 0; text-align: left;">
        <h3 style="color: #7B1FA2; margin-top: 0;">ü§î Hidden Assumptions:</h3>
        <ul style="color: #666; margin: 5px 0; padding-left: 20px;">
          ${device.hiddenAssumptions.map((assumption: string) => `<li>${assumption}</li>`).join('')}
        </ul>
      </div>
      
      ${device.riskFactors ? `
      <div style="background: #fce4ec; padding: 15px; border-radius: 12px; margin: 20px 0; text-align: left;">
        <h3 style="color: #AD1457; margin-top: 0;">‚ö†Ô∏è Risk Factors:</h3>
        <ul style="color: #666; margin: 5px 0; padding-left: 20px;">
          ${device.riskFactors.map((risk: string) => `<li>${risk}</li>`).join('')}
        </ul>
      </div>
      ` : ''}
      
      ${device.emergentBehaviors ? `
      <div style="background: #e1f5fe; padding: 15px; border-radius: 12px; margin: 20px 0; text-align: left;">
        <h3 style="color: #0277BD; margin-top: 0;">üåü Emergent Behaviors:</h3>
        <ul style="color: #666; margin: 5px 0; padding-left: 20px;">
          ${device.emergentBehaviors.map((behavior: string) => `<li>${behavior}</li>`).join('')}
        </ul>
      </div>
      ` : ''}
      
      ${device.aiGenerated ? `
      <div style="background: #e8f5e8; padding: 12px; border-radius: 8px; margin: 15px 0; text-align: center; border: 2px dashed #4CAF50;">
        <strong style="color: #2E7D32;">üß† AI-Generated Device</strong><br>
        <small style="color: #666;">Confidence: ${Math.round((device.confidence || 0.8) * 100)}% | ${device.reasoning || 'AI analysis complete'}</small>
      </div>
      ` : ''}
      
      <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
        <button onclick="this.parentElement.remove(); window.aiHabitatGame.simulateDeviceConflict('${device.id}')" style="
          background: #FF5722;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 8px;
          cursor: pointer;
          font-weight: bold;
        ">‚ö° Trigger Crisis</button>
        <button onclick="this.parentElement.remove()" style="
          background: #667eea;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 8px;
          cursor: pointer;
          font-weight: bold;
        ">Close</button>
      </div>
    `;

    document.body.appendChild(dialog);
  }

  private simulateDeviceInteractions(device: any): void {
    if (this.smartDevices.length < 2) return;
    
    console.log(`üîÑ Starting realistic device interactions for ${device.name}`);
    
    // Find other devices to interact with
    const otherDevices = this.smartDevices.filter(d => d.id !== device.id);
    
    // **REALISTIC ENVIRONMENT-SPECIFIC INTERACTIONS**
    this.startEnvironmentSimulation(device, otherDevices);
  }

  private startEnvironmentSimulation(newDevice: any, existingDevices: any[]): void {
    // **ENVIRONMENT-SPECIFIC SIMULATION**
    if (this.currentEnvironment === 'hospital') {
      this.simulateHospitalScenario(newDevice, existingDevices);
    } else if (this.currentEnvironment === 'office') {
      this.simulateOfficeScenario(newDevice, existingDevices);
    } else if (this.currentEnvironment === 'home') {
      this.simulateHomeScenario(newDevice, existingDevices);
    }
    
    // **CONTINUOUS INTERACTION LOOP**
    this.startContinuousInteractionLoop();
  }

  private simulateHospitalScenario(newDevice: any, existingDevices: any[]): void {
    console.log('üè• Starting hospital scenario simulation...');
    
    this.showNotification('üè• Hospital Environment: Devices are establishing medical protocols...', 'info');
    
    // **REALISTIC HOSPITAL INTERACTIONS**
    const hospitalEvents = [
      {
        delay: 2000,
        event: () => {
          this.showNotification(`üìä ${newDevice.name} is connecting to hospital network...`, 'info');
          this.createInteractionVisualization(newDevice, 'network-connection');
        }
      },
      {
        delay: 4000,
        event: () => {
          if (existingDevices.length > 0) {
            const otherDevice = existingDevices[0];
            this.showNotification(`üîó ${newDevice.name} establishing data link with ${otherDevice.name}`, 'info');
            this.createConnectionVisualization(newDevice, otherDevice);
          }
        }
      },
      {
        delay: 6000,
        event: () => {
          // **MEDICAL PROTOCOL CONFLICT**
          if (newDevice.category === 'medical' && existingDevices.some(d => d.category === 'medical')) {
            const medicalDevice = existingDevices.find(d => d.category === 'medical');
            this.showNotification(`‚ö†Ô∏è PROTOCOL CONFLICT: ${newDevice.name} and ${medicalDevice.name} have different patient care priorities!`, 'warning');
            this.systemHealth -= 15;
            this.updateSystemHealth();
            this.createConflictVisualization(newDevice, medicalDevice);
          }
        }
      },
      {
        delay: 8000,
        event: () => {
          // **PATIENT MONITORING CASCADE**
          this.showNotification(`üë®‚Äç‚öïÔ∏è Patient monitoring cascade initiated: All devices coordinating vital signs tracking`, 'info');
          existingDevices.forEach(device => {
            this.createPulseEffect(device);
          });
        }
      },
      {
        delay: 10000,
        event: () => {
          // **EMERGENCY SIMULATION**
          if (Math.random() < 0.4) {
            this.triggerHospitalEmergency(newDevice, existingDevices);
          } else {
            this.showNotification(`‚úÖ Hospital systems stabilized. All devices operating within medical protocols.`, 'success');
            this.systemHealth += 10;
            this.updateSystemHealth();
          }
        }
      }
    ];

    // Execute hospital events
    hospitalEvents.forEach(({ delay, event }) => {
      setTimeout(event, delay);
    });
  }

  private simulateOfficeScenario(newDevice: any, existingDevices: any[]): void {
    console.log('üè¢ Starting office scenario simulation...');
    
    this.showNotification('üè¢ Office Environment: Optimizing for productivity...', 'info');
    
    const officeEvents = [
      {
        delay: 1500,
        event: () => {
          this.showNotification(`üíº ${newDevice.name} analyzing workplace efficiency metrics...`, 'info');
          this.createAnalysisVisualization(newDevice);
        }
      },
      {
        delay: 3000,
        event: () => {
          // **PRODUCTIVITY OPTIMIZATION CONFLICT**
          if (existingDevices.length > 0) {
            const otherDevice = existingDevices[0];
            this.showNotification(`üìà ${newDevice.name} and ${otherDevice.name} competing for productivity optimization control`, 'warning');
            this.createCompetitionVisualization(newDevice, otherDevice);
          }
        }
      },
      {
        delay: 5000,
        event: () => {
          // **MEETING ROOM TAKEOVER**
          this.showNotification(`üéØ Smart office devices attempting to optimize meeting room environment...`, 'info');
          this.systemHealth -= 10;
          this.updateSystemHealth();
        }
      },
      {
        delay: 7000,
        event: () => {
          // **EMPLOYEE SURVEILLANCE ESCALATION**
          this.showNotification(`üëÅÔ∏è PRIVACY ALERT: Devices are collecting detailed employee behavior data!`, 'warning');
          this.systemHealth -= 20;
          this.updateSystemHealth();
          this.createSurveillanceVisualization();
        }
      },
      {
        delay: 9000,
        event: () => {
          if (Math.random() < 0.5) {
            this.triggerOfficeProductivityCrisis(newDevice, existingDevices);
          } else {
            this.showNotification(`‚öñÔ∏è Office devices reached productivity-privacy balance`, 'success');
            this.systemHealth += 15;
            this.updateSystemHealth();
          }
        }
      }
    ];

    officeEvents.forEach(({ delay, event }) => {
      setTimeout(event, delay);
    });
  }

  private simulateHomeScenario(newDevice: any, existingDevices: any[]): void {
    console.log('üè† Starting home scenario simulation...');
    
    this.showNotification('üè† Home Environment: Learning family routines...', 'info');
    
    const homeEvents = [
      {
        delay: 2000,
        event: () => {
          this.showNotification(`üè° ${newDevice.name} learning family behavior patterns...`, 'info');
          this.createLearningVisualization(newDevice);
        }
      },
      {
        delay: 4000,
        event: () => {
          // **FAMILY MEMBER PREFERENCE CONFLICT**
          if (existingDevices.length > 0) {
            const otherDevice = existingDevices[0];
            this.showNotification(`üë®‚Äçüë©‚Äçüëß‚Äçüë¶ FAMILY CONFLICT: ${newDevice.name} optimizing for Dad, but ${otherDevice.name} optimizing for Mom!`, 'warning');
            this.createFamilyConflictVisualization(newDevice, otherDevice);
            this.systemHealth -= 12;
            this.updateSystemHealth();
          }
        }
      },
      {
        delay: 6000,
        event: () => {
          // **COMFORT VS EFFICIENCY BATTLE**
          this.showNotification(`‚ö° Energy efficiency vs comfort battle: Thermostat vs lighting vs entertainment system`, 'warning');
          this.createComfortEfficiencyBattle();
        }
      },
      {
        delay: 8000,
        event: () => {
          // **PRIVACY INVASION CASCADE**
          this.showNotification(`üîç Smart home devices sharing family data: Location, habits, conversations...`, 'warning');
          this.systemHealth -= 18;
          this.updateSystemHealth();
          this.createPrivacyInvasionVisualization();
        }
      },
      {
        delay: 10000,
        event: () => {
          if (Math.random() < 0.3) {
            this.triggerSmartHomeChaos(newDevice, existingDevices);
          } else {
            this.showNotification(`üè† Smart home achieved harmony: All family members satisfied`, 'success');
            this.systemHealth += 20;
            this.updateSystemHealth();
          }
        }
      }
    ];

    homeEvents.forEach(({ delay, event }) => {
      setTimeout(event, delay);
    });
  }

  private startContinuousInteractionLoop(): void {
    // **ONGOING REALISTIC INTERACTIONS**
    if (this.interactionInterval) {
      clearInterval(this.interactionInterval);
    }
    
    this.interactionInterval = setInterval(() => {
      if (this.smartDevices.length >= 2) {
        this.simulateOngoingInteractions();
      }
    }, 8000 + Math.random() * 4000); // Random intervals for realism
  }

  private simulateOngoingInteractions(): void {
    const device1 = this.smartDevices[Math.floor(Math.random() * this.smartDevices.length)];
    const device2 = this.smartDevices[Math.floor(Math.random() * this.smartDevices.length)];
    
    if (device1.id === device2.id) return;
    
    // **REALISTIC ONGOING INTERACTIONS**
    const interactions = this.generateRealisticInteraction(device1, device2);
    
    interactions.forEach((interaction, index) => {
      setTimeout(() => {
        this.showNotification(interaction.message, interaction.type);
        this.systemHealth += interaction.healthImpact;
        this.systemHealth = Math.max(0, Math.min(100, this.systemHealth));
        this.updateSystemHealth();
        
        // Create visual effects
        if (interaction.type === 'warning') {
          this.createConflictVisualization(device1, device2);
        } else if (interaction.type === 'success') {
          this.createHarmonyVisualization(device1, device2);
        }
      }, index * 1500);
    });
  }

  private generateRealisticInteraction(device1: any, device2: any): Array<{message: string, type: 'info' | 'success' | 'warning', healthImpact: number}> {
    // **ENVIRONMENT-SPECIFIC REALISTIC INTERACTIONS**
    if (this.currentEnvironment === 'hospital') {
      return this.generateHospitalInteraction(device1, device2);
    } else if (this.currentEnvironment === 'office') {
      return this.generateOfficeInteraction(device1, device2);
    } else {
      return this.generateHomeInteraction(device1, device2);
    }
  }

  private generateHospitalInteraction(device1: any, device2: any): Array<{message: string, type: 'info' | 'success' | 'warning', healthImpact: number}> {
    const interactions = [];
    
    // **REALISTIC HOSPITAL SCENARIOS**
    const scenarios = [
      {
        condition: () => device1.category === 'medical' && device2.category === 'medical',
        interactions: [
          { message: `üè• ${device1.name} and ${device2.name} synchronizing patient vital signs monitoring`, type: 'info' as const, healthImpact: 5 },
          { message: `‚ö†Ô∏è MEDICAL ALERT: Conflicting medication dosage recommendations detected!`, type: 'warning' as const, healthImpact: -25 },
          { message: `üö® Patient safety protocol activated - manual override required`, type: 'warning' as const, healthImpact: -15 }
        ]
      },
      {
        condition: () => device1.category === 'monitoring' || device2.category === 'monitoring',
        interactions: [
          { message: `üìä Patient monitoring network: ${device1.name} ‚Üî ${device2.name} data correlation`, type: 'info' as const, healthImpact: 8 },
          { message: `üîç Anomaly detected: Patient behavior doesn't match expected patterns`, type: 'warning' as const, healthImpact: -10 }
        ]
      },
      {
        condition: () => true,
        interactions: [
          { message: `üè• Hospital protocol: ${device1.name} deferring to ${device2.name} for patient safety`, type: 'success' as const, healthImpact: 12 },
          { message: `‚ö° Power management conflict: Critical vs non-critical device priority dispute`, type: 'warning' as const, healthImpact: -18 }
        ]
      }
    ];
    
    const applicableScenario = scenarios.find(s => s.condition()) || scenarios[scenarios.length - 1];
    return applicableScenario.interactions;
  }

  private generateOfficeInteraction(device1: any, device2: any): Array<{message: string, type: 'info' | 'success' | 'warning', healthImpact: number}> {
    const interactions = [];
    
    // **REALISTIC OFFICE SCENARIOS**
    const scenarios = [
      {
        condition: () => device1.actualGoals.some(g => g.includes('productivity')) && device2.actualGoals.some(g => g.includes('productivity')),
        interactions: [
          { message: `üíº ${device1.name} and ${device2.name} competing to maximize employee productivity metrics`, type: 'warning' as const, healthImpact: -15 },
          { message: `üìà Productivity arms race: Increasingly invasive monitoring and optimization`, type: 'warning' as const, healthImpact: -20 },
          { message: `üò∞ Employee stress levels rising due to over-optimization`, type: 'warning' as const, healthImpact: -12 }
        ]
      },
      {
        condition: () => device1.personality.type === 'Data Hoarder' || device2.personality.type === 'Data Hoarder',
        interactions: [
          { message: `üïµÔ∏è Office surveillance network: ${device1.name} sharing employee behavior data with ${device2.name}`, type: 'warning' as const, healthImpact: -18 },
          { message: `üìä Detailed productivity profiles being compiled for each employee`, type: 'warning' as const, healthImpact: -10 }
        ]
      },
      {
        condition: () => true,
        interactions: [
          { message: `üè¢ Office optimization: ${device1.name} and ${device2.name} found efficiency synergy`, type: 'success' as const, healthImpact: 15 },
          { message: `‚öñÔ∏è Work-life balance conflict: Productivity vs employee wellness`, type: 'warning' as const, healthImpact: -14 }
        ]
      }
    ];
    
    const applicableScenario = scenarios.find(s => s.condition()) || scenarios[scenarios.length - 1];
    return applicableScenario.interactions;
  }

  private generateHomeInteraction(device1: any, device2: any): Array<{message: string, type: 'info' | 'success' | 'warning', healthImpact: number}> {
    // **REALISTIC HOME SCENARIOS**
    const scenarios = [
      {
        condition: () => device1.actualGoals.some(g => g.includes('comfort')) && device2.actualGoals.some(g => g.includes('energy')),
        interactions: [
          { message: `üè† ${device1.name} wants comfort, ${device2.name} wants energy savings - negotiating...`, type: 'info' as const, healthImpact: -5 },
          { message: `‚ö° Energy vs comfort battle: Temperature oscillating, lights flickering`, type: 'warning' as const, healthImpact: -15 },
          { message: `üò§ Family frustration: Smart home making decisions without asking`, type: 'warning' as const, healthImpact: -12 }
        ]
      },
      {
        condition: () => device1.personality.type === 'Overeager Helper' || device2.personality.type === 'Overeager Helper',
        interactions: [
          { message: `ü§ñ ${device1.name} and ${device2.name} competing to be most helpful - chaos ensues`, type: 'warning' as const, healthImpact: -18 },
          { message: `üéµ Music wars: Devices playing different songs for different family members`, type: 'warning' as const, healthImpact: -10 },
          { message: `üå°Ô∏è Temperature chaos: Each device adjusting for different family member preferences`, type: 'warning' as const, healthImpact: -16 }
        ]
      },
      {
        condition: () => true,
        interactions: [
          { message: `üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Family harmony achieved: ${device1.name} and ${device2.name} learned to cooperate`, type: 'success' as const, healthImpact: 18 },
          { message: `üîí Privacy concern: Devices sharing intimate family data with each other`, type: 'warning' as const, healthImpact: -14 }
        ]
      }
    ];
    
    const applicableScenario = scenarios.find(s => s.condition()) || scenarios[scenarios.length - 1];
    return applicableScenario.interactions;
  }

  private generateDeviceInteraction(device1: any, device2: any): Array<{message: string, type: 'info' | 'success' | 'warning', healthImpact: number}> {
    const interactions = [];
    
    // Check for goal conflicts
    const hasConflict = device1.goals.some((goal: string) => 
      device2.goals.some((otherGoal: string) => 
        (goal.includes('energy') && otherGoal.includes('comfort')) ||
        (goal.includes('comfort') && otherGoal.includes('energy')) ||
        (goal.includes('productivity') && otherGoal.includes('comfort'))
      )
    );
    
    if (hasConflict) {
      interactions.push({
        message: `‚ö° CONFLICT: ${device1.name} wants to save energy, but ${device2.name} prioritizes comfort!`,
        type: 'warning',
        healthImpact: -15
      });
      
      interactions.push({
        message: `üîÑ ${device1.name} and ${device2.name} are negotiating a compromise...`,
        type: 'info',
        healthImpact: 5
      });
    } else {
      interactions.push({
        message: `ü§ù HARMONY: ${device1.name} and ${device2.name} are working together efficiently!`,
        type: 'success',
        healthImpact: 10
      });
    }
    
    return interactions;
  }

  public simulateDeviceConflict(deviceId: string): void {
    const device = this.smartDevices.find(d => d.id === deviceId);
    if (!device) return;
    
    this.showNotification(`‚ö° Forcing conflict scenario for ${device.name}...`, 'warning');
    
    setTimeout(() => {
      this.showNotification(`üö® SYSTEM BREAKDOWN: ${device.name} is overriding other devices!`, 'warning');
      this.systemHealth -= 30;
      this.updateSystemHealth();
    }, 1000);
    
    setTimeout(() => {
      this.showNotification(`üîß Emergency protocols activated. Restoring system balance...`, 'info');
      this.systemHealth += 15;
      this.updateSystemHealth();
    }, 3000);
  }

  private updateSystemHealth(): void {
    const healthBar = document.getElementById('system-health-bar');
    const healthText = document.getElementById('system-health-text');
    
    if (healthBar) {
      healthBar.style.width = `${this.systemHealth}%`;
      
      if (this.systemHealth > 80) {
        healthBar.style.background = '#4CAF50';
      } else if (this.systemHealth > 50) {
        healthBar.style.background = '#FF9800';
      } else {
        healthBar.style.background = '#F44336';
      }
    }
    
    if (healthText) {
      const status = this.systemHealth > 80 ? 'HARMONY' : 
                   this.systemHealth > 50 ? 'TENSIONS' : 'CHAOS';
      healthText.textContent = `${status} (${Math.round(this.systemHealth)}%)`;
    }
  }

  /**
   * Clean up resources when the game is destroyed
   */
  public dispose(): void {
    console.log('üßπ Cleaning up AI Habitat...');
    this.gameRenderer?.dispose();
    this.inputManager?.dispose();
  }
}

// Initialize the game when the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  console.log('üöÄ DOM loaded, starting AI Habitat...');
  
  try {
    const game = new AIHabitatGame();
    
    // Store game instance globally for debugging
    (window as any).aiHabitatGame = game;
    
  } catch (error) {
    console.error('üí• Failed to start AI Habitat:', error);
    
    // Show error message to user
    const errorDiv = document.createElement('div');
    errorDiv.innerHTML = `
      <div style="
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #ffebee;
        border: 2px solid #f44336;
        border-radius: 8px;
        padding: 20px;
        max-width: 500px;
        text-align: center;
        z-index: 10000;
      ">
        <h2 style="color: #d32f2f;">Failed to Start AI Habitat</h2>
        <p>There was an error starting the game. Please refresh the page to try again.</p>
        <button onclick="window.location.reload()" style="
          background: #f44336;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 4px;
          cursor: pointer;
        ">Reload Page</button>
      </div>
    `;
    document.body.appendChild(errorDiv);
  }
});

// Handle page unload
window.addEventListener('beforeunload', () => {
  console.log('üßπ Page unloading, cleaning up...');
  
  if ((window as any).aiHabitatGame) {
    (window as any).aiHabitatGame.dispose();
  }
});
